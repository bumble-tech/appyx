{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Appyx","text":"<p>Model-driven navigation + UI components with gesture control for Compose Multiplatform.</p> <p>https://github.com/bumble-tech/appyx</p> <p>Find us on Kotlinlang Slack: #appyx</p>"},{"location":"#setup","title":"Setup","text":"<p>See Downloads and Navigation quick start guide.</p>"},{"location":"#overview","title":"Overview","text":"<p>Appyx is a collection of libraries:</p> <p></p>"},{"location":"#appyx-navigation","title":"Appyx Navigation","text":"<p>Type-safe navigation for Compose Multiplatform directly from code.</p> <ul> <li>Tree-based, composable</li> <li>Leverages the transitions and gesture-based capabilities of Appyx Interactions to build beautiful, custom navigation.</li> <li>Use any component for navigation, whether pre-built (Appyx Components), or custom-built by you (Appyx Interactions).</li> </ul> <p>\u00bb More details</p>"},{"location":"#appyx-interactions","title":"Appyx Interactions","text":"<p>Component kit for Compose Multiplatform.</p> <ul> <li>Create custom UI components quickly, which can then be used on their own, or inside your navigation tree.</li> <li>Animation without writing animation code.</li> <li>Gesture control without the usual gesture detection code.</li> </ul> <p>\u00bb More details</p>"},{"location":"#appyx-components","title":"Appyx Components","text":"<p>Component gallery. </p> <p>Back stack, Spotlight (pager), and other UI components built using Appyx Interactions.</p> <p>\u00bb More details</p>"},{"location":"#where-to-start","title":"Where to start?","text":"<p>Depending on what's your use-case with Appyx:</p>"},{"location":"#appyx-as-a-navigation-solution","title":"Appyx as a navigation solution","text":"<p>Check out Appyx Navigation and some of the Appyx Components you can use in your navigation tree.</p>"},{"location":"#creating-your-own-components","title":"Creating your own components","text":"<p>Stacks, custom pagers, custom UI components \u2013 whether for navigation, or standalone: check out what Appyx Interactions can do for you.</p>"},{"location":"#2x-migration-guide","title":"2.x migration guide","text":"<p>If you used Appyx <code>1.x</code> before, you can find a summary of differences here.</p>"},{"location":"#1x-documentation","title":"1.x documentation","text":"<p>This page is about Appyx <code>2.x</code> (alpha).</p> <p>You can find <code>1.x</code> related documentation here.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#navigation-related","title":"Navigation-related","text":""},{"location":"faq/#q-how-does-appyx-navigation-relate-to-jetpack-compose-navigation","title":"Q: How does Appyx Navigation relate to Jetpack Compose Navigation?","text":"<p>We wrote an article on this in the context of Appyx 1.x: Appyx vs Jetpack Compose Navigation.</p> <p>Most of the same arguments apply to Appyx 2.x too.</p> <p>While Appyx represents a different paradigm, it can also co-exist with Jetpack Compose Navigation. This can be helpful if you want to use Appyx for in-screen mechanisms only, or if you plan to migrate gradually.</p> <p>See Appyx + Compose Navigation for more details.</p>"},{"location":"faq/#q-how-does-appyx-navigation-compare-against-other-solutions","title":"Q: How does Appyx Navigation compare against other solutions?","text":"<p>The core concepts of navigation in Appyx differ from most navigation libraries: </p> <ol> <li>You don't have a concept of the \"screen\" present in the model</li> <li>You can define your own navigation models using Appyx Components</li> <li>On the UI level you can transform what feels like the \"screen\" itself</li> </ol> <p>See Model-driven navigation for more details.</p>"},{"location":"faq/#q-how-can-i-navigate-to-a-specific-part-of-my-appyx-tree","title":"Q: How can I navigate to a specific part of my Appyx tree?","text":"<p>In most cases Implicit navigation can be your primary choice, and you don't need to explicitly specify a remote point in the tree. This is helpful to avoid coupling.</p> <p>For those cases when you can't avoid it, Explicit navigation and Deep linking covers you.</p>"},{"location":"faq/#q-what-about-dialogs-bottom-sheets","title":"Q: What about dialogs &amp; bottom sheets?","text":"<p>You can use Appyx in conjunction with Accompanist or any other Compose mechanism.</p> <p>If you wish, you can model your own Modal with Appyx too. We'll add an example soon.</p>"},{"location":"faq/#using-appyx-in-an-app","title":"Using Appyx in an app","text":""},{"location":"faq/#q-is-it-an-all-or-nothing-approach","title":"Q: Is it an all or nothing approach?","text":"<p>No, you can adopt Appyx gradually:</p> <ul> <li>Plug an Appyx Components in to any screen and just use it as a UI component.</li> <li>Plug it in to a few screens and substitute another navigation mechanism with it, such as Jetpack Compose Navigation</li> </ul>"},{"location":"faq/#q-what-architectural-patterns-can-i-use","title":"Q: What architectural patterns can I use?","text":"<p>Appyx is agnostic of architectural patterns. You can use any architectural pattern in the <code>Nodes</code> you'd like. You can even use a different one in each.</p>"},{"location":"faq/#q-can-i-use-it-with-viewmodel","title":"Q: Can I use it with ViewModel?","text":"<p>Please see Appyx + ViewModel.</p>"},{"location":"faq/#q-can-i-use-it-with-hilt","title":"Q: Can I use it with Hilt?","text":"<p>Please see Appyx + DI frameworks.</p>"},{"location":"faq/#performance-related","title":"Performance-related","text":""},{"location":"faq/#q-are-nodes-kept-alive","title":"Q: Are <code>Nodes</code> kept alive?","text":"<p>In short: you can decide whether a <code>Node</code>:</p> <ul> <li>is on-screen</li> <li>is off-screen but kept alive</li> <li>is off-screen and becomes destroyed</li> </ul> <p>Check the Lifecycle for more details.</p>"},{"location":"faq/#on-the-project-itself","title":"On the project itself","text":""},{"location":"faq/#q-is-it-production-ready","title":"Q: Is it production ready?","text":"<p>Appyx matured to its stable version in the <code>1.x</code> branch. </p> <p>The <code>2.x</code> branch is currently in alpha. </p> <p>We use Appyx at Bumble in production, and as such, we're committed to maintaining and improving it.</p>"},{"location":"faq/#other","title":"Other","text":"<p>Have a question? Come over to #appyx on Kotlinlang Slack!</p>"},{"location":"1.x/","title":"Overview","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/#appyx","title":"Appyx","text":"<p>Model-driven navigation for Jetpack Compose</p> <p>https://github.com/bumble-tech/appyx</p>"},{"location":"1.x/#navigation-for-your-compose-app-on-steroids","title":"Navigation for your Compose app on steroids","text":"<ul> <li>Navigate directly from code \u2013 In a type-safe way, without boilerplate</li> <li>Gain control of navigation state \u2013 Making your navigation unit-testable</li> <li>Complete control over operations and behaviour \u2013 Use and extend the back stack or the view pager from the library, or build your own </li> <li>Your own navigation \u2013 With Appyx, you can define your own navigation models</li> <li>Use any animation for transitions \u2013 Anything you can represent with Compose <code>Modifiers</code></li> </ul>"},{"location":"1.x/#model-driven-navigation-a-different-paradigm-with-superpowers","title":"Model-driven navigation \u2013 a different paradigm with superpowers","text":"<p>Using Appyx you gain navigation superpowers in addition to screen-to-screen navigation:  </p> <ul> <li>Break down screen boundaries \u2013 Using <code>NavModels</code> you can navigate inside the screen as well as between them</li> <li>Make your navigation composable \u2013 Navigate whole scopes of your application </li> </ul> <p>Using a model-driven approach, navigation states are yours to define \u2013 Appyx makes it happen with any animation you can represent using Compose <code>Modifiers</code>. Back stacks, card stacks, view pagers are just the beginning:</p> <p> </p> <p>You can create custom navigable components in no time:</p> <p></p> <p>With Appyx you can break down screen boundaries and transform the screen itself:</p> <p></p> <p>See Model-driven navigation for more details.</p>"},{"location":"1.x/#launch-the-demo-app","title":"Launch the demo app","text":"<p>Check out the project and launch the <code>:app</code> module for a quick demonstration!</p>"},{"location":"1.x/#download","title":"Download","text":"<p>See the Downloads page.</p>"},{"location":"1.x/#learning-appyx","title":"Learning Appyx","text":"<p>Check out the Quick start guide, Codelabs, and Sample apps!</p>"},{"location":"1.x/#articles","title":"Articles","text":"<ol> <li>Appyx is released! (1.0-alpha02)</li> <li>Appyx vs Jetpack Compose Navigation</li> <li>Modelling dating cards navigation with Appyx</li> </ol>"},{"location":"1.x/#videos","title":"Videos","text":"<p> Model-driven navigation with Jetpack Compose </p> <p> Model-driven navigation with Appyx</p>"},{"location":"1.x/deprecation/","title":"Deprecation","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/faq/","title":"FAQ","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/faq/#faq","title":"FAQ","text":""},{"location":"1.x/faq/#navigation-related","title":"Navigation-related","text":""},{"location":"1.x/faq/#q-how-does-appyx-relate-to-jetpack-compose-navigation","title":"Q: How does Appyx relate to Jetpack Compose Navigation?","text":"<p>We wrote an article on this: Appyx vs Jetpack Compose Navigation</p> <p>While Appyx represents a different paradigm, it can also co-exist with Jetpack Compose Navigation. This can be helpful if you want to use Appyx for in-screen mechanisms only, or if you plan to migrate gradually.</p> <p>See Sample apps for more details.</p>"},{"location":"1.x/faq/#q-how-does-appyx-compare-against-other-navigation-solutions","title":"Q: How does Appyx compare against other navigation solutions?","text":"<p>The core concepts of navigation in Appyx differ from most navigation libraries: </p> <ol> <li>You don't have a concept of the \"screen\" present in the model</li> <li>You can define your own navigation models</li> <li>On the UI level you can transform what feels like the \"screen\" itself</li> </ol> <p>See Model-driven navigation for more details.</p>"},{"location":"1.x/faq/#q-how-can-i-navigate-to-a-specific-part-of-my-appyx-tree","title":"Q: How can I navigate to a specific part of my Appyx tree?","text":"<p>In most cases Implicit navigation can be your primary choice, and you don't need to explicitly specify a remote point in the tree. This is helpful to avoid coupling.</p> <p>For those cases when you can't avoid it, Explicit navigation and Deep linking covers you.</p>"},{"location":"1.x/faq/#q-what-about-dialogs-bottom-sheets","title":"Q: What about dialogs &amp; bottom sheets?","text":"<p>You can use Appyx in conjunction with Accompanist or any other Compose mechanism.</p> <p>If you wish, you can model your own Modal with Appyx too. We'll add an example soon.</p>"},{"location":"1.x/faq/#q-can-i-have-a-bottom-sheet-conditionally","title":"Q: Can I have a bottom sheet conditionally?","text":"<p>You could use a similar approach as we do with back buttons in <code>SamplesContainerNode</code> you can find in the <code>:app</code> module: store a flag in the <code>NavTarget</code> that can be different per instance.</p>"},{"location":"1.x/faq/#using-appyx-in-an-app","title":"Using Appyx in an app","text":""},{"location":"1.x/faq/#q-is-it-an-all-or-nothing-approach","title":"Q: Is it an all or nothing approach?","text":"<p>No, you can adopt Appyx gradually:</p> <ul> <li>Plug it in to one screen and just utilise its screen transformation capabilities (e.g. Cards)</li> <li>Plug it in to a few screens and substitute another navigation mechanism with it, such as Jetpack Compose Navigation</li> </ul>"},{"location":"1.x/faq/#q-what-architectural-patterns-can-i-use","title":"Q: What architectural patterns can I use?","text":"<p>Appyx is agnostic of architectural patterns. You can use any architectural pattern in the <code>Nodes</code> you'd like. You can even use a different one in each.</p>"},{"location":"1.x/faq/#q-can-i-use-it-with-viewmodel","title":"Q: Can I use it with ViewModel?","text":"<p>Yes, we'll add an example soon.</p>"},{"location":"1.x/faq/#q-can-i-use-it-with-hilt","title":"Q: Can I use it with Hilt?","text":"<ul> <li>Our draft PR: #115 (Feel free to provide feedback!)</li> <li>https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic</li> </ul>"},{"location":"1.x/faq/#performance-related","title":"Performance-related","text":""},{"location":"1.x/faq/#q-are-nodes-kept-alive","title":"Q: Are <code>Nodes</code> kept alive?","text":"<p>In short: you can decide whether a <code>Node</code>:</p> <ul> <li>is on-screen</li> <li>is off-screen but kept alive</li> <li>is off-screen and becomes destroyed</li> </ul> <p>Check the Lifecycle for more details.</p>"},{"location":"1.x/faq/#on-the-project-itself","title":"On the project itself","text":""},{"location":"1.x/faq/#q-is-it-production-ready","title":"Q: Is it production ready?","text":"<p>Yes, Appyx matured to its stable version. We also use it at Bumble in production, and as such, we're committed to maintaining and improving it.</p>"},{"location":"1.x/faq/#q-whats-your-roadmap","title":"Q: What's your roadmap?","text":"<p>We're full with ideas where to take Appyx further! A more detailed roadmap will be added later. Come back for more updates.</p>"},{"location":"1.x/faq/#other","title":"Other","text":"<p>Have a question? Raise it in Discussions!.</p>"},{"location":"1.x/apps/childaware/","title":"ChildAware API","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/apps/childaware/#childaware-api","title":"ChildAware API","text":"<p>The framework includes the <code>ChildAware</code> interface which comes with a powerful API.</p> <p>It allows you to scope communication with (or between) dynamically available child nodes easily.</p>"},{"location":"1.x/apps/childaware/#baseline","title":"Baseline","text":"<p>In the next examples:</p> <ol> <li>Let's assume that <code>SomeNode</code> can host multiple child nodes: <code>Child1</code>, <code>Child2</code>, etc.</li> <li><code>SomeInteractor</code> belongs to <code>SomeNode</code> and is passed as a Plugin    to it</li> <li><code>SomeInteractor</code> extends the <code>Interactor</code> helper class from the framework:<ul> <li>It implements <code>NodeLifecycleAware</code>, which makes sure it will receive the <code>onCreate</code> callback   from the framework</li> <li>It implements <code>ChildAware</code>, which unlocks the DSL we'll see in the following   snippets</li> </ul> </li> </ol>"},{"location":"1.x/apps/childaware/#single-child-scenario","title":"Single child scenario","text":"<pre><code>import androidx.lifecycle.Lifecycle\nimport com.bumble.appyx.core.children.whenChildAttached\nimport com.bumble.appyx.core.children.whenChildrenAttached\nimport com.bumble.appyx.core.clienthelper.interactor.Interactor\n\n\nclass SomeInteractor : Interactor&lt;SomeNode&gt;() {\n\n    override fun onCreate(lifecycle: Lifecycle) {\n        lifecycle.subscribe(onCreate = {\n\n            // This lambda is executed every time a node of type Child1Node is attached:\n            whenChildAttached { commonLifecycle: Lifecycle, child1: Child1Node -&gt;\n                // TODO:\n                //  - establish communication with child1 \n                //  - use commonLifecycle for scoping \n                //  - it will be capped by the lifecycles of child1 and the parent\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"1.x/apps/childaware/#multiple-children","title":"Multiple children","text":"<pre><code>import androidx.lifecycle.Lifecycle\nimport com.bumble.appyx.core.children.whenChildAttached\nimport com.bumble.appyx.core.children.whenChildrenAttached\nimport com.bumble.appyx.core.clienthelper.interactor.Interactor\n\n\nclass SomeInteractor : Interactor&lt;SomeNode&gt;() {\n\n    override fun onCreate(lifecycle: Lifecycle) {\n        lifecycle.subscribe(onCreate = {\n\n            // This lambda is executed every time these two nodes are attached at the same time:\n            whenChildrenAttached { commonLifecycle: Lifecycle, child1: Child1Node, child2: Child2Node -&gt;\n                // TODO\n                //  - establish communication between child1 &amp; child2 \n                //  - use commonLifecycle for scoping\n                //  - it will be capped by the lifecycles of child1, child2 and the parent\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"1.x/apps/configuration/","title":"Configuration changes","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/apps/configuration/#configuration-change","title":"Configuration change","text":"<p>To retain objects during configuration change you can use the <code>RetainedInstanceStore</code> class.</p>"},{"location":"1.x/apps/configuration/#how-does-it-work","title":"How does it work?","text":"<p>The <code>RetainedInstanceStore</code> stores the objects within a singleton. The node manages whether the content should be removed by checking whether the <code>Activity</code> is being recreated due to a configuration change or not.</p> <p>These are the following scenarios: - If the <code>Activity</code> is recreated: the retained instance is returned instead of a new instance. - If the <code>Activity</code> is destroyed: the retained instance is removed and disposed.</p>"},{"location":"1.x/apps/configuration/#example","title":"Example","text":"<p>Here is an example of how you can use the <code>RetainedInstanceStore</code>:</p> <pre><code>import com.bumble.appyx.core.builder.Builder\nimport com.bumble.appyx.core.modality.BuildContext\nimport com.bumble.appyx.core.node.Node\nimport com.bumble.appyx.core.store.getRetainedInstance\nimport com.bumble.appyx.interop.rx2.store.getRetainedDisposable\n\nclass RetainedInstancesBuilder : Builder&lt;String&gt;() {\n\n    override fun build(buildContext: BuildContext, payload: String): Node {\n        val retainedNonDisposable = buildContext.getRetainedInstance(\n            factory = { NonDisposableClass(payload) },\n            disposer = { feature.cleanUp() }\n        ) \n        val retainedFeature = buildContext.getRetainedDisposable {\n            RetainedInstancesFeature(payload)\n        }\n\n        val view = RetainedInstancesViewImpl()\n        val interactor = RetainedInstancesInteractor(\n            feature = retainedFeature,\n            nonDisposable = retainedNonDisposable,\n            view = view\n        )\n\n        return RetainedInstancesNode(\n            buildContext = buildContext,\n            view = view,\n            plugins = listOf(interactor)\n        )\n    }\n}\n</code></pre>"},{"location":"1.x/apps/lifecycle/","title":"Lifecycle","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/apps/lifecycle/#lifecycle","title":"Lifecycle","text":"<p>Nodes have their own lifecycles, directly using the related classes of <code>androidx.lifecycle</code>.</p>"},{"location":"1.x/apps/lifecycle/#capping","title":"Capping","text":"<p>No node can be in a higher lifecycle state than any of its parents or the Android Activity it lives in.</p>"},{"location":"1.x/apps/lifecycle/#on-screen-off-screen","title":"On-screen &amp; off-screen","text":"<p><code>NavModel</code> controls which children should be rendered on the screen and which should not with <code>NavModel.screenState</code>. The behaviour is customisable in <code>BaseNavModel</code> via <code>OnScreenStateResolver</code>.</p> <p>When a <code>NavElement</code> of the node is marked as on-screen, its lifecycle follows the parent node's lifecycle. The rendering status does not affect it \u2013 the node might not be added to Compose view and still be in a <code>RESUMED</code> state.</p> <p>When a <code>NavElement</code> of the node is marked as off-screen, the following might happen:</p> <ul> <li>Its lifecycle is capped with <code>CREATED</code> (or <code>STOPPED</code>) in case of <code>ChildEntry.KeepMode.KEEP</code>. </li> <li>The node is destroyed and its state is saved in case of <code>ChildEntry.KeepMode.SUSPEND</code>.</li> </ul> <p><code>ChildEntry.KeepMode</code> settings can be configured for each <code>ParentNode</code> individually or globally via <code>Appyx.defaultChildKeepMode</code>.</p> <p>When a node is removed completely from <code>NavModel</code>, it will be in <code>DESTROYED</code> state.</p>"},{"location":"1.x/apps/lifecycle/#lifecycle-changes","title":"Lifecycle changes","text":"<p>The lifecycle state can be affected by:</p> <ul> <li>The NavModel of the parent (adding or removing child <code>Nodes</code> and changing their on-screen status)</li> <li>The parent's lifecycle state capping its children (transitive in the tree)</li> <li>Android lifecycle (Activity) capping the whole tree</li> </ul>"},{"location":"1.x/apps/lifecycle/#back-stack-node-lifecycle","title":"Back stack node lifecycle","text":"<p>An example demonstrating the above:</p> <p></p> <p>Note that NavModels might have their slight differences (e.g. whether their operations remove a <code>Node</code> only from the view, or completely destroy it).</p> <p>In the case of the back stack:</p> <ul> <li>The <code>Push</code> operation adds a new element and stashes the currently active one \u2013 the stashed one will be removed from the view &amp; <code>STOPPED</code></li> <li>The <code>Pop</code> operation removes an element, the child <code>Node</code> will be <code>DESTROYED</code></li> </ul>"},{"location":"1.x/apps/plugins/","title":"Plugins","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/apps/plugins/#plugins","title":"Plugins","text":""},{"location":"1.x/apps/plugins/#keeping-extra-concerns-out-of-node","title":"Keeping extra concerns out of Node","text":"<p><code>Nodes</code> are meant to be simple structural elements, and should be kept lean.</p> <p>To keep the framework agnostic of any specific approach / pattern you want to use, there aren't any fixed parts. Rather, the <code>Node</code> offers an extension point using <code>Plugins</code> in its constructor:</p> <pre><code>abstract class Node(\n    buildContext: BuildContext,\n    val view: NodeView = EmptyNodeView,\n    plugins: List&lt;Plugin&gt; = emptyList() // &lt;--\n)\n</code></pre> <p>So what is a <code>Plugin</code>?</p> <p>A <code>Plugin</code> is an empty interface extended by many actual ones:</p> <pre><code>interface Plugin\n</code></pre>"},{"location":"1.x/apps/plugins/#plugins_1","title":"Plugins","text":""},{"location":"1.x/apps/plugins/#lifecycle-related-plugins","title":"Lifecycle-related plugins","text":"<pre><code>interface NodeLifecycleAware : Plugin {\n    fun onCreate(lifecycle: Lifecycle) {}\n}\n\nfun interface Destroyable : Plugin {\n    fun destroy()\n}\n</code></pre>"},{"location":"1.x/apps/plugins/#component-level-plugins","title":"Component level plugins","text":"<p>Sometimes you need to grab a reference to the component as a whole, either as an interface, or its implementation, the <code>Node</code>.</p> <p>This will come especially handy when working with workflows.</p> <pre><code>interface NodeAware : Plugin {\n    val node: Node&lt;*&gt;\n\n    fun init(node: Node&lt;*&gt;) {}\n}\n</code></pre> <p>There are helper classes found in the library, so you don't have to implement the above interfaces, you can just use delegation:</p> <pre><code>class SomeClass(\n    private val nodeAware: NodeAware = NodeAwareImpl()\n) : NodeAware by nodeAware {\n\n    fun foo() {\n        // [node] is an automatically available property coming from the NodeAware interface\n        // the reference is automatically set for you by the framework + the NodeAwareImpl class\n        // so you can use it right away:\n        node.doSomething()\n    }\n}\n</code></pre> <p>\u26a0\ufe0f Note: the reference to <code>node</code> is set by <code>Node</code> automatically, and isn't available immediately after constructing your object, but only after the construction of the <code>Node</code> itself.</p>"},{"location":"1.x/apps/plugins/#navigation-plugins","title":"Navigation plugins","text":"<p>In case if you need to control navigation behaviour, you can use these plugins:</p> <pre><code>interface UpNavigationHandler : Plugin {\n    fun handleUpNavigation(): Boolean = false\n}\n\ninterface BackPressHandler : Plugin {\n    val onBackPressedCallback: OnBackPressedCallback? get() = null\n}\n</code></pre> <p><code>UpNavigationHandler</code> controls <code>Node.navigateUp</code> behaviour and allows to intercept its invocation.</p> <p><code>BackPressHandler</code> controls device back press behaviour via <code>androidx.activity.OnBackPressedCallback</code>. You can read more about it here.</p> <p>\u26a0\ufe0f Note: <code>OnBackPressedCallback</code> are invoked in the following order: 1. From children to parents. Render order of children matters! The last rendered child will be the first to handle back press. 2. Direct order of plugins within a node. Plugins are invoked in order they appears in <code>Node(plugins = ...)</code> before the NavModel. </p>"},{"location":"1.x/apps/plugins/#using-plugins","title":"Using Plugins","text":"<p>All plugins are designed to have empty <code>{}</code> default implementations (or other sensible defaults when a return value is defined), so it's convenient to implement them only if you need.</p> <p>Don't forget to pass your <code>Plugins</code> to your <code>Node</code>:</p> <pre><code>internal class MyNode(\n    // ...\n    plugins: List&lt;Plugins&gt; = emptyList()\n    // ...\n) : Node&lt;Nothing&gt;(\n    // ...\n    plugins = plugins\n    // ...\n)\n</code></pre> <p>\u26a0\ufe0f Note: <code>plugins</code> is a <code>List</code>, as the order matters here. All <code>Plugin</code> instances are invoked in the order they appear in the list.</p>"},{"location":"1.x/apps/structure/","title":"Structuring your app navigation","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/apps/structure/#structuring-your-app-navigation","title":"Structuring your app navigation","text":"<p>As seen in Composable navigation, you can make <code>NavModels</code> composable. </p> <p>To achieve this, Appyx offers the <code>Node</code> class as the structural element.</p>"},{"location":"1.x/apps/structure/#node-illustration","title":"Node illustration","text":"<p>In many of the examples you'll see this panel as an illustration of a very simple <code>Node</code> \u2013 it has some local state (id, colour, and a counter).</p> <p></p> <p>If you launch the sample app in the <code>:app</code> module, you can also change its state (colour) by tapping it. Its counter is stepped automatically. This is to illustrate that it has its own state, persisted and restored.</p>"},{"location":"1.x/apps/structure/#node-overview","title":"Node overview","text":"<p>You can think of a <code>Node</code> as a standalone component with:</p> <ul> <li>Its own simplified lifecycle</li> <li>State restoration</li> <li>A <code>@Composable</code> view</li> <li>Business logic that's kept alive even when the view isn't added to the composition</li> <li>The ability to host generic Plugins to extract extra concerns without enforcing any particular architectural pattern</li> </ul>"},{"location":"1.x/apps/structure/#parent-nodes-child-nodes","title":"Parent nodes, child nodes","text":"<p><code>ParentNodes</code> can have other <code>Nodes</code> as children. This means you can represent your whole application as a tree of Appyx nodes.</p> <p></p> <p>You can go as granular or as high-level as it fits you. This allows to keep the complexity low in individual <code>Nodes</code> by extracting responsibilities to children, as well as composing other components to build more complex functionality.</p>"},{"location":"1.x/apps/structure/#composable-navigation","title":"Composable navigation","text":"<p><code>Nodes</code> offer the structure \u2013 <code>NavModels</code> add dynamism to it.</p> <p>Read more in Composable navigation</p>"},{"location":"1.x/apps/structure/#lifecycle","title":"Lifecycle","text":"<p>Nodes have their own lifecycles, directly using the related classes of <code>androidx.lifecycle</code>.</p> <p>Read more in Lifecycle</p>"},{"location":"1.x/apps/structure/#childaware-api","title":"ChildAware API","text":"<p>React to dynamically added child nodes in the tree: ChildAware API </p>"},{"location":"1.x/apps/structure/#summary","title":"Summary","text":"<p>A summary of Appyx's approach to structuring applications:</p> <ul> <li>Compose your app out of <code>Nodes</code> with their own lifecycles and state</li> <li>Navigation is local, composed of individual pieces of <code>NavModels</code></li> <li>Navigation is stateful</li> <li>Navigation is unit-testable</li> <li>You're free to implement your own navigable components by utilising <code>NavModels</code></li> <li>Avoid global navigation concerns, like shared modules needing to know about the application, or the application needing to know about all its possible modules</li> </ul>"},{"location":"1.x/how-to-use-appyx/codelabs/","title":"Codelabs","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/how-to-use-appyx/codelabs/#appyx-codelabs","title":"Appyx codelabs","text":"<p>When you feel ready, try our Coding challenges too!</p>"},{"location":"1.x/how-to-use-appyx/codelabs/#1-hello-world-with-appyx","title":"1. Hello World with Appyx","text":"<p>Learn the basics of Appyx</p> <p></p>"},{"location":"1.x/how-to-use-appyx/codelabs/#2-navigation","title":"2. Navigation","text":"<p>Learn how Appyx navigation works</p> <p></p>"},{"location":"1.x/how-to-use-appyx/codelabs/#3-custom-animation","title":"3. Custom animation","text":"<p>Learn how to unleash powerful transitions</p> <p></p>"},{"location":"1.x/how-to-use-appyx/coding-challenges/","title":"Coding challenges","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/how-to-use-appyx/coding-challenges/#appyx-coding-challenges","title":"Appyx coding challenges","text":""},{"location":"1.x/how-to-use-appyx/coding-challenges/#droidcon-london-22-coding-challenge-1","title":"Droidcon London 22 \u2013 Coding challenge 1","text":"<p>Test your knowledge of the key pieces of Appyx</p> <p></p>"},{"location":"1.x/how-to-use-appyx/coding-challenges/#droidcon-london-22-coding-challenge-2","title":"Droidcon London 22 \u2013 Coding challenge 2","text":"<p>A challenge with custom animations and a new operation</p> <p></p>"},{"location":"1.x/how-to-use-appyx/quick-start/","title":"Quick start guide","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/how-to-use-appyx/quick-start/#quick-start-guide","title":"Quick start guide","text":"<p>Info</p> <ul> <li>You can check out App structure, which explains the concepts you'll encounter in this guide.</li> <li>You can check out the project and launch the <code>:app</code> module for a quick demonstration</li> </ul> <p>Tip</p> <p>Once you're familiar with Appyx, you can also clone the https://github.com/bumble-tech/appyx-starter-kit when starting a new project, instead of following this guide below.</p>"},{"location":"1.x/how-to-use-appyx/quick-start/#scope-of-this-guide","title":"Scope of this guide","text":"<p>The steps below will cover:</p> <ol> <li>Integrating Appyx into your project</li> <li>Creating a very simple <code>Node</code> hierarchy</li> <li>We'll use a simple back stack for navigation</li> <li>We'll add some simple transitions to it</li> </ol> <p>This should be enough to get you started as a rudimentary application structure.</p> <p>Tutorials &amp; codelabs on more advanced topics &amp; the full power of Appyx to follow soon.</p>"},{"location":"1.x/how-to-use-appyx/quick-start/#1-add-appyx-to-your-project","title":"1. Add Appyx to your project","text":"<p>You can find the related Gradle dependencies in Downloads.</p>"},{"location":"1.x/how-to-use-appyx/quick-start/#2-create-a-root-node","title":"2. Create a root Node","text":"<pre><code>class RootNode(\n    buildContext: BuildContext\n) : Node(\n    buildContext = buildContext\n) {\n    @Composable\n    override fun View(modifier: Modifier) {\n        Text(\"Hello world!\")\n    }\n}\n</code></pre> <p>Since this is the root of your tree, you'll also need to plug it in to your Activity, so that system events (Android lifecycle, back press, etc.) reach your components in the tree.</p> <pre><code>// Please note we are extending NodeActivity\nclass MainActivity : NodeActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            AppTheme {\n                NodeHost(integrationPoint = appyxIntegrationPoint) {\n                    RootNode(buildContext = it)\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>You only need to do this for the root of the tree.</p>"},{"location":"1.x/how-to-use-appyx/quick-start/#3-define-children","title":"3. Define children","text":"<p>A single leaf node isn't all that interesting. Let's add some children to the root!</p> <p>First, let's define the possible set of children using a sealed class. We'll refer them via these navigation targets:</p> <pre><code>/**\n * You can create this class inside the body of RootNode\n * \n * Note: You must apply the 'kotlin-parcelize' plugin to use @Parcelize\n * https://developer.android.com/kotlin/parcelize\n */\nsealed class NavTarget : Parcelable {\n    @Parcelize\n    object Child1 : NavTarget()\n\n    @Parcelize\n    object Child2 : NavTarget()\n\n    @Parcelize\n    object Child3 : NavTarget()\n}\n</code></pre> <p>Next, let's modify <code>RootNode</code> so it extends <code>ParentNode</code>:</p> <pre><code>class RootNode(\n    buildContext: BuildContext\n) : ParentNode&lt;NavTarget&gt;(\n    navModel = TODO(\"We will come back to this in Step 4\"),\n    buildContext = buildContext\n) {\n</code></pre> <p><code>ParentNode</code> expects us to implement the abstract method <code>resolve</code>. This is how we relate navigation targets to actual children. Let's use these helper methods to define some placeholders for the time being \u2013 we'll soon make them more appealing:</p> <pre><code>override fun resolve(navTarget: NavTarget, buildContext: BuildContext): Node =\n    when (navTarget) {\n        NavTarget.Child1 -&gt; node(buildContext) { Text(text = \"Placeholder for child 1\") }\n        NavTarget.Child2 -&gt; node(buildContext) { Text(text = \"Placeholder for child 2\") } \n        NavTarget.Child3 -&gt; node(buildContext) { Text(text = \"Placeholder for child 3\") }\n    }\n</code></pre> <p>Great! With this mapping created, we can now just refer to children using the sealed class elements, and Appyx will be able to relate them to other nodes.</p>"},{"location":"1.x/how-to-use-appyx/quick-start/#4-add-a-back-stack","title":"4. Add a back stack","text":"<p>The project wouldn't compile just yet. <code>ParentNode</code> expects us to pass an instance of a <code>NavModel</code> \u2013 the main control structure in any case when we want to add children. No need to worry now \u2013 for simplicity, let's just go with a simple <code>BackStack</code> implementation here:</p> <pre><code>class RootNode(\n    buildContext: BuildContext,\n    private val backStack: BackStack&lt;NavTarget&gt; = BackStack(\n        initialElement = NavTarget.Child1,\n        savedStateMap = buildContext.savedStateMap,\n    )\n) : ParentNode&lt;NavTarget&gt;(\n    navModel = backStack, // pass it here\n    buildContext = buildContext\n) {\n</code></pre> <p>With this simple addition we've immediately gained a lot of power! Now we can use the back stack's API to add, replace, pop children with operations like:</p> <pre><code>backStack.push(NavTarget.Child2)    // will add a new navigation target to the end of the stack and make it active \nbackStack.replace(NavTarget.Child3) // will replace the currently active child\nbackStack.pop()                     // will remove the currently active child and restore the one before it\n</code></pre> <p>Since we passed the back stack to the <code>ParentNode</code>, all such changes will be immediately reflected. We only need to add it to the composition:</p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\n    Column {\n        Text(\"Hello world!\")\n        // Let's add the children to the composition\n        Children(\n            navModel = backStack\n        )\n\n        // Let's also add some controls so we can test it\n        Row {\n            TextButton(onClick = { backStack.push(NavTarget.Child1) }) {\n                Text(text = \"Push child 1\")\n            }\n            TextButton(onClick = { backStack.push(NavTarget.Child2) }) {\n                Text(text = \"Push child 2\")\n            }\n            TextButton(onClick = { backStack.push(NavTarget.Child3) }) {\n                Text(text = \"Push child 3\")\n            }\n            TextButton(onClick = { backStack.pop() }) {\n                Text(text = \"Pop\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1.x/how-to-use-appyx/quick-start/#5-add-transitions","title":"5. Add transitions","text":"<p>Adding some transitions is a one-liner:</p> <pre><code>Children(\n    navModel = backStack,\n    transitionHandler = rememberBackstackSlider()\n)\n</code></pre> <p>You can also use a fader instead: <code>rememberBackstackFader()</code>, and you can supply a transition spec in both cases: <code>rememberBackStackSlider { spring(stiffness = Spring.StiffnessLow) }</code></p> <p>Need something more custom?</p> <ol> <li>Instead of a back stack, you can find other NavModels in the library, or you can implement your own</li> <li>Instead of the default transition handlers, you can also use Jetpack Compose provided ones, or supply your own</li> </ol> <p>You can also read the Back stack documentation for more info on the specific options for the back stack.</p>"},{"location":"1.x/how-to-use-appyx/quick-start/#6-proper-child-nodes","title":"6. Proper child nodes","text":"<p>As a last step, let's replace at least one of the child placeholders with another proper node.</p> <p>Let's create a dedicated class:</p> <pre><code>class SomeChildNode(\n    buildContext: BuildContext\n) : Node(\n    buildContext = buildContext\n) {\n    @Composable\n    override fun View(modifier: Modifier) {\n        Text(\"This is SomeChildNode\")\n    }\n}\n</code></pre> <p>Now we can update the <code>resolve</code> method in <code>RootNode</code> so that the target <code>Child3</code> refers to this node. It should work out of the box:</p> <pre><code>override fun resolve(navTarget: NavTarget, buildContext: BuildContext): Node =\n    when (navTarget) {\n        NavTarget.Child1 -&gt; node(buildContext) { Text(text = \"Placeholder for child 1\") }\n        NavTarget.Child2 -&gt; node(buildContext) { Text(text = \"Placeholder for child 2\") } \n        NavTarget.Child3 -&gt; SomeChildNode(buildContext)\n    }\n</code></pre>"},{"location":"1.x/how-to-use-appyx/quick-start/#whats-next","title":"What's next?","text":"<p>Congrats, you've just built your first Appyx tree!</p> <p>You can repeat the same pattern and make any embedded children also a <code>ParentNode</code> with their own children, navigation models, and transitions. As complexity grows, generally you would:</p> <ol> <li>Have a <code>Node</code></li> <li>At some point make it a <code>ParentNode</code> and add children to it</li> <li>At some point extract the increasing complexity from a placeholder to another <code>Node</code> </li> <li>Repeat the same on children, go to <code>1.</code></li> </ol>"},{"location":"1.x/how-to-use-appyx/quick-start/#further-reading","title":"Further reading","text":"<ul> <li>Check out Model-driven navigation how to take your navigation to the next level</li> <li>You can (and probably should) also extract local business logic, the view, any any other components into separate classes and Plugins.</li> </ul>"},{"location":"1.x/how-to-use-appyx/sample-apps/","title":"Sample apps","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/how-to-use-appyx/sample-apps/#appyx-sample-apps","title":"Appyx sample apps","text":""},{"location":"1.x/how-to-use-appyx/sample-apps/#where-to-find-the-sample-apps","title":"Where to find the sample apps","text":"<ol> <li>Go to the GitHub project</li> <li>Fork and check out the code locally</li> <li>Import the project to Android Studio</li> </ol> <p>You can find the pre-built sample app apks here:</p> <ul> <li>Latest release</li> <li>Latest 1.x</li> </ul>"},{"location":"1.x/how-to-use-appyx/sample-apps/#showcase-app","title":"Showcase app","text":"<p>The <code>:app</code> module showcases Appyx itself with multiple levels of navigation, NavModel demos, etc. See it in action, then check the related code how it works.</p>"},{"location":"1.x/how-to-use-appyx/sample-apps/#appyx-jetpack-compose-navigation-example","title":"Appyx + Jetpack Compose Navigation example","text":"<p>The <code>:samples:navigation-compose</code> module demonstrates how to use Appyx within Google's Jetpack Compose Navigation library. This example may be useful if you need to migrate to Appyx gradually.</p>"},{"location":"1.x/how-to-use-appyx/sample-apps/#appyx-hilt-example","title":"Appyx + Hilt example","text":"<p>Coming soon!</p> <p>Meanwhile:</p> <ul> <li>Our draft PR: #115 (Feel free to provide feedback!)</li> <li>https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic</li> </ul>"},{"location":"1.x/navigation/composable-navigation/","title":"Composable navigation","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navigation/composable-navigation/#composable-navigation","title":"Composable navigation","text":"<p>NavModels in Appyx are composable. </p> <p>As a single <code>NavModel</code> won't be enough for the whole of your whole app, you can use many in a composable way. That is, any navigation target of a <code>NavModel</code> can also host its own <code>NavModel</code>.</p>"},{"location":"1.x/navigation/composable-navigation/#structural-element-for-composing-navigation","title":"Structural element for composing navigation","text":"<p><code>Nodes</code> are the main structural element in Appyx. They can host <code>NavModels</code>, and they form a tree.</p> <p>This allows you to make your app's business logic also composable by leveraging <code>Nodes</code> as lifecycled components.</p> <p>Read more in Structuring your app navigation</p>"},{"location":"1.x/navigation/composable-navigation/#navigation-in-the-tree","title":"Navigation in the tree","text":"<p>Once you've structured your navigation in a composable way, you can add <code>NavModels</code> to <code>Node</code> of this tree and make it dynamic:</p> <ul> <li>Some parts in this tree are active while others ore not</li> <li>The active parts define what state the application is in, and what the user sees on the screen</li> <li>We can change what's active by using <code>NavModels</code> on each level of the tree</li> <li>Changes will feel like navigation to the user</li> </ul> <p>See Implicit navigation and Explicit navigation for building complex navigation behaviours with this approach.</p>"},{"location":"1.x/navigation/composable-navigation/#how-navmodels-affect-nodes","title":"How NavModels affect Nodes","text":"<p>NavModel operations will typically result in:</p> <ul> <li>Adding or removing child <code>Nodes</code> of a <code>ParentNode</code></li> <li>Move them on and off the screen</li> <li>Change their states</li> </ul> <p>As an illustration:</p> <p> </p> <p>Here:</p> <ul> <li><code>Back stack</code> illustrates adding and removing child <code>Nodes</code></li> <li><code>Tiles</code> illustrates changing the state of children and removing them from the <code>ParentNode</code></li> </ul> <p>These are just two examples, you're of course not limited to using them.</p>"},{"location":"1.x/navigation/deep-linking/","title":"Deep linking","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navigation/deep-linking/#deep-linking","title":"Deep linking","text":"<p>Building on top of explicit navigation, implementing deep links is straightforward:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n    lateinit var rootNode: RootNode\n\n    fun handleDeepLink(intent: Intent) {\n        if (intent.action == Intent.ACTION_VIEW) {\n            when {\n                (it.data?.host == \"onboarding\") -&gt; navigateToOnBoarding()\n                else -&gt; Unit\n            }\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            NodeHost(integrationPoint = appyxIntegrationPoint) {\n                RootNode(\n                    buildContext = it,\n                    plugins = listOf(object : NodeReadyObserver&lt;RootNode&gt; {\n                        override fun init(node: RootNode) {\n                            rootNode = node\n                            handleDeepLink(intent = intent)\n                        }\n                    })\n                )\n            }\n        }\n    }\n\n    private fun navigateToOnBoarding() {\n        // implement explicit navigation\n    }\n}\n</code></pre> <p>Check <code>ExplicitNavigationExampleActivity</code> in the samples to inspect the full code.</p>"},{"location":"1.x/navigation/explicit-navigation/","title":"Explicit navigation","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navigation/explicit-navigation/#explicit-navigation","title":"Explicit navigation","text":"<p>When Implicit navigation doesn't fit your use case, you can try an explicit approach.</p> <p>Relevant methods</p> <ul> <li>ParentNode.attachChild()</li> <li>ParentNode.waitForChildAttached()</li> </ul> <p>Using these methods we can chain together a path which leads from the root of the tree to a specific <code>Node</code>.</p>"},{"location":"1.x/navigation/explicit-navigation/#use-case","title":"Use case","text":"<p>We want to navigate from <code>Chat</code></p> <p></p> <p>to onboarding's first screen <code>O1</code>:</p> <p></p> <p>This time we'll want to do this explicitly by calling a function.</p>"},{"location":"1.x/navigation/explicit-navigation/#the-plan","title":"The plan","text":"<ol> <li>Create a public method on <code>Root</code> that attaches <code>Onboarding</code></li> <li>Create a public method on <code>Onboarding</code> that attaches the first onboarding screen</li> <li>Create a <code>Navigator</code>, that starting from an instance of <code>Root</code>, can chain these public methods together into a single action: <code>navigateToO1()</code></li> <li>Capture an instance of <code>Root</code> to use with <code>Navigator</code></li> <li>Call <code>navigateToO1()</code> on our <code>Navigator</code> instance</li> </ol>"},{"location":"1.x/navigation/explicit-navigation/#step-1-root-onboarding","title":"Step 1 \u2013 <code>Root</code> \u2192 <code>Onboarding</code>","text":"<p>First, we need to define how to programmatically attach <code>Onboarding</code> to the <code>Root</code>:</p> <pre><code>class RootNode(\n    buildContext: BuildContext,\n    backStack: BackStack&lt;NavTarget&gt;\n) : ParentNode&lt;NavTarget&gt;(\n    buildContext = buildContext,\n    navModel = backStack,\n) {\n\n    suspend fun attachOnboarding(): OnboardingNode {\n        return attachChild {\n            backStack.replace(NavTarget.Onboarding)\n        }\n    }\n}\n</code></pre> <p>Let's break down what happens here:</p> <ol> <li>Since <code>attachChild</code> has a generic <code>&lt;T&gt;</code> return type, it will conform to the defined <code>OnboardingNode</code> type </li> <li>However, <code>attachChild</code> doesn't know how to create navigation to <code>OnboardingNode</code> \u2013 that's something only we can do with the provided lambda</li> <li>We replace <code>NavTarget.Onboarding</code> into the back stack</li> <li>Doing this should result in <code>OnboardingNode</code> being created and added to <code>RootNode</code> as a child </li> <li><code>attachChild</code> expects an instance of <code>OnboardingNode</code> to appear as a child of <code>Root</code> as a consequence of executing our lambda</li> <li>Once it appears, <code>attachChild</code> returns it</li> </ol> <p>Important</p> <p>It's our responsibility to make sure that the provided lambda actually results in the expected child being added. If we accidentally do something else instead, for example:</p> <pre><code>suspend fun attachOnboarding(): OnboardingNode {\n    return attachChild {\n        backStack.replace(NavTarget.Main) // Wrong NavTarget\n    }\n}\n</code></pre> <p>Then an exception will be thrown after a timeout.</p>"},{"location":"1.x/navigation/explicit-navigation/#step-2-onboarding-o1","title":"Step 2 \u2013 <code>Onboarding</code> \u2192 <code>O1</code>","text":"<p>Unlike <code>Root</code>, <code>Onboarding</code> uses Spotlight instead of BackStack as a <code>NavModel</code>, so navigation to the first screen is slightly different:  </p> <pre><code>class OnboardingNode(\n    buildContext: BuildContext,\n    spotlight: Spotlight&lt;NavTarget&gt;\n) : ParentNode&lt;NavTarget&gt;(\n    buildContext = buildContext,\n    navModel = spotlight,\n) {\n\n    suspend fun attachO1(): O1Node {\n        return attachChild {\n            spotlight.activate(index = 0)\n        }\n    }\n}\n</code></pre>"},{"location":"1.x/navigation/explicit-navigation/#step-3-our-navigator","title":"Step 3 \u2013 Our <code>Navigator</code>","text":"<pre><code>interface Navigator {\n     fun navigateToO1()\n}\n</code></pre> <p>In this case we'll implement it directly with our activity:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n    lateinit var rootNode: RootNode // See the next step\n\n     override fun navigateToO1() {\n         lifecycleScope.launch {\n             rootNode\n                 .attachOnboarding()\n                 .attachO1()\n         }\n     }\n}\n</code></pre>"},{"location":"1.x/navigation/explicit-navigation/#step-4-an-instance-of-rootnode","title":"Step 4 \u2013 An instance of <code>RootNode</code>","text":"<p>As the last piece of the puzzle, we'll also need to capture the instance of <code>RootNode</code> to make it all work. We can do that by a <code>NodeReadyObserver</code> plugin when setting up our tree:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n    lateinit var rootNode: RootNode\n\n    override fun navigateToO1() { /*...*/ }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            NodeHost(integrationPoint = appyxIntegrationPoint) {\n                RootNode(\n                    buildContext = it,\n                    navigator = this@ExplicitNavigationExampleActivity,\n                    plugins = listOf(object : NodeReadyObserver&lt;RootNode&gt; {\n                        override fun init(node: RootNode) {\n                            rootNode = node\n                        }\n                    })\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1.x/navigation/explicit-navigation/#step-5-using-the-navigator","title":"Step 5 \u2013 Using the <code>Navigator</code>","text":"<p>See how in the previous snippet <code>RootNode</code> receives a <code>navigator</code> dependency. </p> <p>It can pass it further down the tree as a dependency to other nodes. Those nodes can call the methods of the <code>Navigator</code>, which will change the global navigation state directly.</p>"},{"location":"1.x/navigation/explicit-navigation/#bonus-wait-for-a-child-to-be-attached","title":"Bonus: Wait for a child to be attached","text":"<p>There might be cases when we want to wait for a certain action to be performed by the user, rather than us, to result in a child being attached.</p> <p>In these cases we can use <code>ParentNode.waitForChildAttached()</code> instead.</p>"},{"location":"1.x/navigation/explicit-navigation/#use-case-wait-for-login","title":"Use case \u2013 Wait for login","text":"<p>A typical case building an explicit navigation chain that relies on <code>Logged in</code> being attached. Most probably <code>Logged in</code> has a dependency on some kind of a <code>User</code> object. Here we want to wait for the user to authenticate themselves, rather than creating a dummy user object ourselves.</p> <pre><code>class RootNode(\n    buildContext: BuildContext,\n) : ParentNode&lt;NavTarget&gt;(\n    buildContext = buildContext\n) {\n\n    suspend fun waitForLoggedIn(): LoggedInNode = \n        waitForChildAttached&lt;LoggedInNode&gt;()\n}\n</code></pre> <p>This method will wait for <code>LoggedInNode</code> to appear in the child list of <code>RootNode</code> and return with it. If it's already there, it returns immediately.</p> <p>A navigation chain using it could look like:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n     override fun navigateToProfile() {\n         lifecycleScope.launch {\n             rootNode\n                 .waitForLoggedIn()\n                 .attachMain()\n                 .attachProfile()\n         }\n     }\n}\n</code></pre> <p>You can find related code examples in <code>ExplicitNavigationExampleActivity</code> in our samples.</p>"},{"location":"1.x/navigation/implicit-navigation/","title":"Implicit navigation","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navigation/implicit-navigation/#implicit-navigation","title":"Implicit navigation","text":"<p>How can we go from one part of the tree to another? In almost all cases navigation can be implicit instead of explicit. We don't need to specify the target \u2013 navigation will happen as a consequence of individual pieces of the puzzle.</p> <p>Relevant methods</p> <ul> <li><code>ParentNode.onChildFinished(child: Node)</code> can be overridden by client code to handle a child finishing</li> <li><code>Node.finish()</code> invokes the above method on its parent</li> </ul>"},{"location":"1.x/navigation/implicit-navigation/#use-case-1","title":"Use-case 1","text":""},{"location":"1.x/navigation/implicit-navigation/#requirement","title":"Requirement","text":"<p>After onboarding finishes, the user should land in the message list screen.</p>"},{"location":"1.x/navigation/implicit-navigation/#solution","title":"Solution","text":"<ol> <li><code>O3</code> calls its <code>finish()</code> method</li> <li><code>Onboarding</code> notices <code>O3</code> finished; if it had more children, it could switch to another; now it calls <code>finish()</code> too</li> <li><code>Logged in</code> notices <code>Onboarding</code> finished, and switches its navigation to <code>Main</code></li> <li><code>Main</code> is initialised, and loads its default navigation target (based on product requirements) to be <code>Messages</code></li> <li><code>Messages</code> is initialised, and loads its default navigation target to be <code>List</code></li> </ol> <p>Bonus</p> <p>Every <code>Node</code> in the above sequence only needed to care about its own local concern.</p>"},{"location":"1.x/navigation/implicit-navigation/#use-case-2","title":"Use-case 2","text":""},{"location":"1.x/navigation/implicit-navigation/#requirement_1","title":"Requirement","text":"<p>Pressing the logout button on the profile screen should land us back to the login screen.</p>"},{"location":"1.x/navigation/implicit-navigation/#solution_1","title":"Solution","text":"<ol> <li><code>Root</code> either implements a <code>logout</code> callback, or subscribes to the changes of a user repository; in both cases, either the callback or the repository is passed down the tree as a dependency</li> <li><code>Profile</code> invokes the callback or a <code>logout</code> method on the repository</li> <li><code>Root</code> notices the state change, and switches its navigation to the <code>Logged out</code> scope</li> <li><code>Logged out</code> loads its initial navigation target, <code>Login</code></li> </ol> <p>Bonus</p> <p>Note how the entire <code>Logged in</code> scope is destroyed without any extra effort. The next time a login happens, all state is created anew. </p>"},{"location":"1.x/navigation/implicit-navigation/#summary","title":"Summary","text":"<p>Implicit navigation allows you to implement navigation without introducing unnecessary coupling in the tree, and successfully covers the majority of navigation scenarios.</p> <p>In case it's not enough to meet your needs, see the next chapter, Explicit navigation</p>"},{"location":"1.x/navigation/model-driven-navigation/","title":"Model-driven navigation","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navigation/model-driven-navigation/#model-driven-navigation","title":"Model-driven navigation","text":""},{"location":"1.x/navigation/model-driven-navigation/#your-own-navigation-model","title":"Your own navigation model","text":"<p>Generally speaking, most navigation solutions have fixed navigation mechanisms (e.g. a back stack).</p> <p>Appyx gives you the freedom to define your own navigation model. For example, you can implement any of the examples you see here with the same approach:</p> <p> </p>"},{"location":"1.x/navigation/model-driven-navigation/#no-screen-only-a-viewport","title":"No screen, only a viewport","text":"<p>Generally speaking, most navigation solutions model a \"Screen\" and focus on how to get from one screen to another.</p> <p>Appyx does not have the concept of the screen in its model \u2013 there's only a viewport, and whatever fills the available space will feel like the screen to the user.</p> <p>This freedom allows you to implement:</p> <ul> <li>navigation that feels like going from \"screen to screen\"</li> <li>navigation \"inside the screen\"</li> <li>navigation that bridges between the two</li> </ul> <p>For example, you can transform the screen itself as part of navigation:</p> <p></p>"},{"location":"1.x/navigation/model-driven-navigation/#navmodels","title":"NavModels","text":"<p>A <code>NavModel</code> implements any of the above mechanisms. </p> <p>See NavModels for more details. </p>"},{"location":"1.x/navigation/model-driven-navigation/#composable-navigation","title":"Composable navigation","text":"<p><code>NavModels</code> in Appyx are composable.</p> <p>See Composable navigation for more details.</p>"},{"location":"1.x/navmodel/","title":"Overview","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navmodel/#navigation-models","title":"Navigation models","text":"<p>Navigation model is a core concept of Appyx.</p>"},{"location":"1.x/navmodel/#whats-a-navmodel","title":"What's a NavModel?","text":"<p>Navigation models describe navigation itself \u2013 by the states and operations they define, any custom navigation mechanism can be implemented.</p> <p><code>NavModel</code> capabilities differ across implementations, however, typically:</p> <ol> <li>They store information on the states of all children </li> <li>They behave like a state machine</li> <li>They offer some public API to trigger changing the state of children  </li> </ol>"},{"location":"1.x/navmodel/#some-examples-of-navigation-models","title":"Some examples of navigation models","text":"<p>You can take a look at some of these examples:</p> <ol> <li>Back stack</li> <li>Spotlight</li> <li>Tiles</li> <li>Promoter carousel</li> </ol> <p>When you feel ready, you can try to implement your own NavModel.</p>"},{"location":"1.x/navmodel/#what-does-a-navmodel-not-do","title":"What does a NavModel not do?","text":"<p>The <code>NavModel</code> represents only the model, not the looks:</p> <ul> <li>UI representation depends on your <code>@Composable</code> view hosting the children \u2013 See Adding children to the view</li> <li>Transition animations (if any) is a separate concern</li> </ul>"},{"location":"1.x/navmodel/backstack/","title":"Back stack","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navmodel/backstack/#back-stack","title":"Back stack","text":"<p>Implements a simple linear history:</p> <ul> <li>The last element at the end of the stack is considered \"active\".</li> <li>All other elements are considered stashed.</li> <li>Children associated with stashed elements are off the screen but kept alive (see how the counter values reflect this on the video)</li> </ul> <p>The back stack can never be empty \u2013 it always contains at least one element.</p> <p>The back stack also supports different back press and operation strategies (see further down below).</p>"},{"location":"1.x/navmodel/backstack/#states","title":"States","text":"<pre><code>enum class State {\n    CREATED, ACTIVE, STASHED, DESTROYED,\n}\n</code></pre>"},{"location":"1.x/navmodel/backstack/#visualisation-of-states","title":"Visualisation of states","text":"<p>Check out the apps in our Coding challenges \u2013 they have an embedded visualisation of what happens to all the elements inside the back stack (look at the row of orange boxes below the logo). </p>"},{"location":"1.x/navmodel/backstack/#constructing-the-back-stack","title":"Constructing the back stack","text":"<p>As the back stack can never be empty, it's required to define an initial target.</p> <pre><code>class BackStack&lt;NavTarget : Any&gt;(\n    initialElement: NavTarget,\n    savedStateMap: SavedStateMap?,\n    // Optional parameters are omitted\n)\n</code></pre>"},{"location":"1.x/navmodel/backstack/#default-on-screen-resolution","title":"Default on screen resolution","text":"<p>As a default, only the active element is considered on screen.</p> <pre><code>object BackStackOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\n    override fun isOnScreen(state: State): Boolean =\n        when (state) {\n            State.CREATED,\n            State.STASHED,\n            State.DESTROYED -&gt; false\n            State.ACTIVE -&gt; true\n        }\n}\n</code></pre>"},{"location":"1.x/navmodel/backstack/#default-transition-handlers","title":"Default transition handlers","text":""},{"location":"1.x/navmodel/backstack/#backstackfader","title":"BackStackFader","text":"<p><code>rememberBackstackFader()</code></p> <p>Adds simple cross-fading transitions</p>"},{"location":"1.x/navmodel/backstack/#backstackslider","title":"BackStackSlider","text":"<p><code>rememberBackstackSlider()</code></p> <p>Adds horizontal sliding transitions so that the <code>ACTIVE</code> element is in the center; other states are animated from / to the left or the right edge of the screen.</p>"},{"location":"1.x/navmodel/backstack/#operations","title":"Operations","text":""},{"location":"1.x/navmodel/backstack/#push","title":"Push","text":"<p><code>backStack.push(navTarget)</code></p> <p>Effect on stack:  <pre><code>[A, B, C] + Push(D) = [A, B, C, D]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>STASHED</code>. Adds a new element at the end of the stack with a <code>CREATED</code> -&gt; <code>ACTIVE</code> transition.</p>"},{"location":"1.x/navmodel/backstack/#replace","title":"Replace","text":"<p><code>backStack.replace(navTarget)</code></p> <p>Effect on stack:  <pre><code>[A, B, C] + Replace(D) = [A, B, D]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>DESTROYED</code>, which will be removed when the transition finishes. Adds a new element at the end of the stack with a <code>CREATED</code> -&gt; <code>ACTIVE</code> transition.</p>"},{"location":"1.x/navmodel/backstack/#pop","title":"Pop","text":"<p><code>backStack.pop(navTarget)</code></p> <p>Effect on stack:  <pre><code>[A, B, C] + Pop = [A, B]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>DESTROYED</code>, which will be removed when the transition finishes. Transitions the last stashed element <code>STASHED</code> -&gt; <code>ACTIVE</code>.</p>"},{"location":"1.x/navmodel/backstack/#single-top","title":"Single top","text":"<p><code>backStack.singleTop(navTarget)</code></p> <p>Effect on stack: depends on the contents of the stack:</p> <pre><code>[A, B, C, D] + SingleTop(B)  = [A, B]          // of same type and equals, acts as n * Pop\n[A, B, C, D] + SingleTop(B') = [A, B']         // of same type but not equals, acts as n * Pop + Replace\n[A, B, C, D] + SingleTop(E)  = [A, B, C, D, E] // not found, acts as Push\n</code></pre>"},{"location":"1.x/navmodel/backstack/#back-press-strategy","title":"Back press strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class BackStack&lt;NavTarget : Any&gt;(\n    /* ... */\n    backPressHandler: BackPressHandlerStrategy&lt;NavTarget, State&gt; = PopBackPressHandler(),\n    /* ... */\n) \n</code></pre>"},{"location":"1.x/navmodel/backstack/#popbackpresshandler","title":"PopBackPressHandler","text":"<p>The default back press handling strategy. Runs a <code>Pop</code> operation.</p>"},{"location":"1.x/navmodel/backstack/#donthandlebackpress","title":"DontHandleBackPress","text":"<p>Serves as a no-op.</p>"},{"location":"1.x/navmodel/backstack/#operation-strategy","title":"Operation strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class BackStack&lt;NavTarget : Any&gt;(\n    /* ... */\n    operationStrategy: OperationStrategy&lt;NavTarget, State&gt; = ExecuteImmediately(),    \n    /* ... */\n)\n</code></pre>"},{"location":"1.x/navmodel/backstack/#executeimmediately","title":"ExecuteImmediately","text":"<p>The default strategy. New operations are executed without any questions, regardless of any already running transitions.</p>"},{"location":"1.x/navmodel/backstack/#finishtransitionsonnewoperation","title":"FinishTransitionsOnNewOperation","text":"<p>All running transitions are abruptly finished when a new one is started</p>"},{"location":"1.x/navmodel/backstack/#queueoperations","title":"QueueOperations","text":"<p>The new operation is queued and executed after the current one finishes</p>"},{"location":"1.x/navmodel/backstack/#ignoreifthereareunfinishedtransitions","title":"IgnoreIfThereAreUnfinishedTransitions","text":"<p>Runs the new one only if there are no transitions happening currently; ignore and discard it otherwise</p>"},{"location":"1.x/navmodel/cards/","title":"Cards","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navmodel/cards/#cards","title":"Cards","text":"<p>Implements a dating-cards-like mechanism.</p> <p>Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful.</p>"},{"location":"1.x/navmodel/cards/#where-can-i-find-this-navmodel","title":"Where can I find this NavModel?","text":"<p>The <code>Cards</code> NavModel is not currently published, however you can try it in <code>:samples:app</code>. Launch the sample app and check the <code>Dating cards NavModel</code> item to see it in action.</p>"},{"location":"1.x/navmodel/cards/#states","title":"States","text":"<pre><code>sealed class State {\n    data class Queued(val queueNumber: Int) : State()\n    object Bottom : State()\n    object Top : State()\n    object IndicateLike : State()\n    object IndicatePass : State()\n    object VoteLike : State()\n    object VotePass : State()\n}\n</code></pre>"},{"location":"1.x/navmodel/cards/#state-transitions","title":"State transitions","text":""},{"location":"1.x/navmodel/cards/#constructing-cards","title":"Constructing <code>Cards</code>","text":"<p>Requires defining items that will be converted to profile cards. The first one in the list will become a <code>Top</code> card, the second one a <code>Bottom</code> card, the rest will be <code>Queued</code>. </p> <pre><code>class Cards&lt;NavTarget : Any&gt;(\n    initialItems: List&lt;NavTarget&gt; = listOf(),\n) : BaseNavModel&lt;NavTarget, State&gt;(\n    screenResolver = CardsOnScreenResolver,\n    finalStates = FINAL_STATES,\n    savedStateMap = null\n) {\n    companion object {\n        internal val FINAL_STATES = setOf(VoteLike, VotePass)\n        internal val TOP_STATES = setOf(Top, IndicateLike, IndicatePass)\n    }\n}\n</code></pre>"},{"location":"1.x/navmodel/cards/#default-on-screen-resolution","title":"Default on screen resolution","text":"<pre><code>internal object CardsOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\n    override fun isOnScreen(state: State): Boolean =\n        when (state) {\n            is State.Bottom,\n            is State.Top,\n            is State.IndicateLike,\n            is State.IndicatePass -&gt; true\n            is State.Queued,\n            is State.VoteLike,\n            is State.VotePass -&gt; false\n        }\n}\n</code></pre>"},{"location":"1.x/navmodel/cards/#default-transition-handlers","title":"Default transition handlers","text":""},{"location":"1.x/navmodel/cards/#cardstransitionhandler","title":"CardsTransitionHandler","text":"<p><code>rememberCardsTransitionHandler()</code></p> <p>Adds scale-up, swipe and rotation animations.</p>"},{"location":"1.x/navmodel/cards/#operations","title":"Operations","text":""},{"location":"1.x/navmodel/cards/#promoteall","title":"PromoteAll","text":"<p>Internal operation. Automatically invoked whenever a top card is moved to a vote-related state. Causes all other cards to come forward in the queue, become the <code>Bottom</code> card, then the <code>Top</code> card.</p>"},{"location":"1.x/navmodel/cards/#indicatelike-indicatepass-votelike-votepass","title":"IndicateLike, IndicatePass, VoteLike, VotePass","text":"<p>Transitions the <code>Top</code> card directly to these states.</p>"},{"location":"1.x/navmodel/custom/","title":"Writing your own","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navmodel/custom/#implementing-your-own-navigation-models","title":"Implementing your own navigation models","text":"<p>A step-by-step guide. You can also take a look at other existing examples to see these in practice.</p>"},{"location":"1.x/navmodel/custom/#step-1","title":"Step 1","text":"<p>Create the class; define your possible states; define your initial state. </p> <pre><code>class Foo&lt;NavTarget : Any&gt;(\n    initialItems: List&lt;NavTarget&gt; = listOf(),\n    savedStateMap: SavedStateMap?\n) : BaseNavModel&lt;NavTarget, Foo.State&gt;(\n    screenResolver = FooOnScreenResolver, // We'll see about this shortly\n    finalState = DESTROYED, // Anything transitioning towards this state will be discarded eventually\n    savedStateMap = savedStateMap // It's nullable if you don't need state restoration\n) {\n\n    // Your possible states for any single navigation target\n    enum class State {\n        CREATED, FOO, BAR, BAZ, DESTROYED;\n    }\n\n    // You can go about it any other way.\n    // Back stack for example defines only a single element.\n    // Here we take all the &lt;NavTarget&gt; elements and make them transition CREATED -&gt; FOO immediately.\n    override val initialElements = initialItems.map {\n        FooElement(\n            key = NavKey(it),\n            fromState = State.CREATED,\n            targetState = State.FOO,\n            operation = Operation.Noop()\n        )\n    }\n}\n</code></pre>"},{"location":"1.x/navmodel/custom/#optional-step-2","title":"(optional) Step 2","text":"<p>Add some convenience aliases:</p> <pre><code>typealias FooElement&lt;NavTarget&gt; = NavElement&lt;NavTarget, Foo.State&gt;\n\ntypealias FooElements&lt;NavTarget&gt; = NavElements&lt;NavTarget, Foo.State&gt;\n\nsealed interface FooOperation&lt;NavTarget&gt; : Operation&lt;NavTarget, Foo.State&gt;\n</code></pre>"},{"location":"1.x/navmodel/custom/#step-3","title":"Step 3","text":"<p>Define one or more operations.</p> <pre><code>@Parcelize\nclass SomeOperation&lt;NavTarget : Any&gt; : FooOperation&lt;NavTarget&gt; {\n\n    override fun isApplicable(elements: FooElements&lt;NavTarget&gt;): Boolean =\n        TODO(\"Define whether this operation is applicable given the current state\")\n\n    override fun invoke(\n        elements: FooElements&lt;NavTarget&gt;,\n    ): NavElements&lt;NavTarget, Foo.State&gt; =\n        // TODO: Mutate elements however you please. Add, remove, change.\n        //  In this example we're changing all elements to transition to BAR.\n        //  You can also use helper methods elements.transitionTo &amp; elements.transitionToIndexed \n        elements.map {\n            it.transitionTo(\n                newTargetState = BAR,\n                operation = this\n            )\n        }\n}\n\n// You can add an extension method for a leaner API\nfun &lt;NavTarget : Any&gt; Foo&lt;NavTarget&gt;.someOperation() {\n    accept(FooOperation())\n}\n</code></pre>"},{"location":"1.x/navmodel/custom/#step-4","title":"Step 4","text":"<p>Add the screen resolver to define which states should be / should not be part of the composition in the end:</p> <pre><code>object FooOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\n    override fun isOnScreen(state: State): Boolean =\n        when (state) {\n            Foo.State.CREATED,\n            Foo.State.DESTROYED -&gt; false\n            Foo.State.FOO,\n            Foo.State.BAR,\n            Foo.State.BAZ, -&gt; true\n        }\n}\n</code></pre>"},{"location":"1.x/navmodel/custom/#step-5","title":"Step 5","text":"<p>Add one or more transition handlers to interpret different states and translate them to Jetpack Compose <code>Modifiers</code>. </p> <pre><code>class FooTransitionHandler&lt;NavTarget&gt;(\n    private val transitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n) : ModifierTransitionHandler&lt;NavTarget, Foo.State&gt;() {\n\n    // TODO define a Modifier depending on the state.\n    //  Here we'll just mutate scaling: \n    override fun createModifier(\n        modifier: Modifier,\n        transition: Transition&lt;Foo.State&gt;,\n        descriptor: TransitionDescriptor&lt;NavTarget, Foo.State&gt;\n    ): Modifier = modifier.composed {\n        val scale = transition.animateFloat(\n            transitionSpec = transitionSpec,\n            targetValueByState = {\n                when (it) {\n                    Foo.State.CREATED -&gt; 0f\n                    Foo.State.FOO -&gt; 0.33f\n                    Foo.State.BAR -&gt; 0.66f\n                    Foo.State.BAZ -&gt; 1.0f\n                    Foo.State.DESTROYED -&gt; 0f\n                }\n            })\n\n        scale(scale.value)\n    }\n}\n\n// TODO remember to add:\n@Composable\nfun &lt;NavTarget&gt; rememberFooTransitionHandler(\n    transitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n): ModifierTransitionHandler&lt;NavTarget, Foo.State&gt; = remember {\n    FooTransitionHandler(transitionSpec)\n}\n</code></pre>"},{"location":"1.x/navmodel/custom/#test-it","title":"Test it","text":"<p>Add <code>Children</code> to your <code>Node</code>. Pass your NavModel and the transition handler:</p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\n    Children(\n        modifier = Modifier.fillMaxSize(),\n        navModel = foo,\n        transitionHandler = rememberFooTransitionHandler()\n    )\n}\n</code></pre> <p>Somewhere else in your business logic trigger the operations you defined. Make sure they're called on the same <code>foo</code> instance that you pass to the <code>Children</code> composable:</p> <pre><code>foo.someOperation()\n</code></pre> <p>As soon as this is triggered, elements should transition to the <code>BAR</code> state in this example, and you should see them scale up defined by the transition handler.</p>"},{"location":"1.x/navmodel/custom/#created-something-cool","title":"Created something cool?","text":"<p>Let us know!</p>"},{"location":"1.x/navmodel/promoter/","title":"Promoter","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navmodel/promoter/#promoter-carousel","title":"Promoter carousel","text":"<p>Intended only as an illustration.</p>"},{"location":"1.x/navmodel/promoter/#where-can-i-find-this-navmodel","title":"Where can I find this NavModel?","text":"<p>The <code>Promoter</code> NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know.</p>"},{"location":"1.x/navmodel/promoter/#states","title":"States","text":"<pre><code>enum class State {\n    CREATED, STAGE1, STAGE2, STAGE3, STAGE4, SELECTED, DESTROYED\n}\n</code></pre>"},{"location":"1.x/navmodel/promoter/#default-on-screen-resolution","title":"Default on screen resolution","text":"<pre><code>internal object PromoterOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\n    override fun isOnScreen(state: State): Boolean =\n        when (state) {\n            State.DESTROYED -&gt; false\n            else -&gt; true\n        }\n}\n</code></pre>"},{"location":"1.x/navmodel/promoter/#default-transition-handler","title":"Default transition handler","text":"<p>As elements are promoted to next stages, they're:</p> <ul> <li>animated on a circular path</li> <li>scaled up</li> <li>rotated in the selection / discard stages</li> </ul> <p>You can check <code>PromoterTransitionHandler</code> for implementation details.</p>"},{"location":"1.x/navmodel/promoter/#operations","title":"Operations","text":""},{"location":"1.x/navmodel/promoter/#add-first","title":"Add first","text":"<p><code>promoter.addFirst(navTarget)</code></p> <p>Adds a new element at the start of the element list with a <code>CREATED</code> state.</p>"},{"location":"1.x/navmodel/promoter/#promote-all","title":"Promote all","text":"<p><code>promoter.promoteAll()</code></p> <p>All elements are transitioned to the next state:</p> <ul> <li><code>CREATED</code> -&gt; <code>STAGE1</code></li> <li><code>STAGE1</code> -&gt; <code>STAGE2</code></li> <li><code>STAGE2</code> -&gt; <code>STAGE3</code></li> <li><code>STAGE3</code> -&gt; <code>STAGE4</code></li> <li><code>STAGE4</code> -&gt; <code>SELECTED</code></li> <li><code>SELECTED</code> -&gt; <code>DESTROYED</code></li> </ul>"},{"location":"1.x/navmodel/spotlight/","title":"Spotlight","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navmodel/spotlight/#spotlight","title":"Spotlight","text":"<p>Implements a mechanism analogous to a view pager; has a single active element (\"it's in the spotlight\", hence the name), but unlike the back stack, it does not remove other elements.</p> <p>It's great for flows or tabbed containers.</p>"},{"location":"1.x/navmodel/spotlight/#states","title":"States","text":"<pre><code>enum class State {\n    INACTIVE_BEFORE, ACTIVE, INACTIVE_AFTER;\n}\n</code></pre>"},{"location":"1.x/navmodel/spotlight/#constructing-spotlight","title":"Constructing spotlight","text":"<p>Requires defining items and an active index.</p> <pre><code>class Spotlight&lt;NavTarget : Any&gt;(\n    items: List&lt;NavTarget&gt;,\n    initialActiveIndex: Int = 0,\n    savedStateMap: SavedStateMap?,\n    // Optional parameters are omitted\n)\n</code></pre>"},{"location":"1.x/navmodel/spotlight/#default-on-screen-resolution","title":"Default on screen resolution","text":"<p>As a default, only the active element is considered on screen.</p> <pre><code>object SpotlightOnScreenResolver : OnScreenStateResolver&lt;Spotlight.State&gt; {\n    override fun isOnScreen(state: Spotlight.State): Boolean =\n        when (state) {\n            Spotlight.State.INACTIVE_BEFORE,\n            Spotlight.State.INACTIVE_AFTER -&gt; false\n            Spotlight.State.ACTIVE -&gt; true\n        }\n}\n</code></pre>"},{"location":"1.x/navmodel/spotlight/#default-transition-handlers","title":"Default transition handlers","text":""},{"location":"1.x/navmodel/spotlight/#spotlightfader","title":"SpotlightFader","text":"<p><code>rememberSpotlightFader()</code></p> <p>Adds simple cross-fading transitions</p>"},{"location":"1.x/navmodel/spotlight/#spotlightslider","title":"SpotlightSlider","text":"<p><code>rememberSpotlightSlider()</code></p> <p>Adds horizontal sliding transitions so that the <code>ACTIVE</code> element is in the center; other states are animated from / to the left or the right edge of the screen, depending on the order of them in the <code>items</code> property.</p>"},{"location":"1.x/navmodel/spotlight/#operations","title":"Operations","text":""},{"location":"1.x/navmodel/spotlight/#activate","title":"Activate","text":"<p><code>spotlight.activate(navTarget)</code></p> <p>Transitions the element to <code>ACTIVE</code>. Transitions other elements to <code>INACTIVE_BEFORE</code> or <code>INACTIVE_AFTER</code> depending on their relative position to the activated element.</p>"},{"location":"1.x/navmodel/spotlight/#next","title":"Next","text":"<p><code>spotlight.next()</code></p> <p>Transitions the currently active element to <code>INACTIVE_BEFORE</code>.  Transitions the element after the currently active one to <code>ACTIVE</code>.</p>"},{"location":"1.x/navmodel/spotlight/#previous","title":"Previous","text":"<p><code>spotlight.previous()</code></p> <p>Transitions the currently active element to <code>INACTIVE_AFTER</code>. Transitions the element before the currently active one to <code>ACTIVE</code>.</p>"},{"location":"1.x/navmodel/spotlight/#update-elements","title":"Update elements","text":"<p><code>spotlight.updateElements(items, activeIndex)</code></p> <p>Replaces elements held by the spotlight instance with a new list. Transitions new elements to <code>INACTIVE_BEFORE</code>, <code>ACTIVE</code>, or <code>INACTIVE_AFTER</code> depending on their position in the provided list relative to <code>activeIndex</code>.</p>"},{"location":"1.x/navmodel/spotlight/#back-press-strategy","title":"Back press strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class Spotlight&lt;NavTarget : Any&gt;(\n    /* ... */\n    backPressHandler: BackPressHandlerStrategy&lt;NavTarget, State&gt; = GoToDefault(\n        initialActiveIndex\n    )\n    /* ... */\n)\n</code></pre>"},{"location":"1.x/navmodel/spotlight/#gotodefault","title":"GoToDefault","text":"<p>The default back press handling strategy. Activates the default index.</p>"},{"location":"1.x/navmodel/spotlight/#gotoprevious","title":"GoToPrevious","text":"<p>Runs a <code>Previous</code> operation.</p>"},{"location":"1.x/navmodel/spotlight/#operation-strategy","title":"Operation strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class Spotlight&lt;NavTarget : Any&gt;(\n    /* ... */\n    operationStrategy: OperationStrategy&lt;NavTarget, State&gt; = ExecuteImmediately(),    \n    /* ... */\n)\n</code></pre>"},{"location":"1.x/navmodel/spotlight/#executeimmediately","title":"ExecuteImmediately","text":"<p>The default strategy. New operations are executed without any questions, regardless of any already running transitions.</p>"},{"location":"1.x/navmodel/tiles/","title":"Tiles","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/navmodel/tiles/#tiles","title":"Tiles","text":"<p>Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful.</p>"},{"location":"1.x/navmodel/tiles/#where-can-i-find-this-navmodel","title":"Where can I find this NavModel?","text":"<p>The <code>Tiles</code> NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know.</p>"},{"location":"1.x/navmodel/tiles/#states","title":"States","text":"<pre><code>enum class State {\n    CREATED, STANDARD, SELECTED, DESTROYED\n}\n</code></pre>"},{"location":"1.x/navmodel/tiles/#default-on-screen-resolution","title":"Default on screen resolution","text":"<pre><code>internal object TilesOnScreenResolver : OnScreenStateResolver&lt;State&gt; {\n    override fun isOnScreen(state: State): Boolean =\n        when (state) {\n            State.CREATED,\n            State.STANDARD,\n            State.SELECTED -&gt; true\n            State.DESTROYED -&gt; false\n        }\n}\n</code></pre>"},{"location":"1.x/navmodel/tiles/#default-transition-handler","title":"Default transition handler","text":"<p>Selection translates to scaling. Destroying makes elements fly off the screen with rotation and downscaling.</p>"},{"location":"1.x/navmodel/tiles/#operations","title":"Operations","text":""},{"location":"1.x/navmodel/tiles/#add","title":"Add","text":"<p><code>tiles.add(navTarget)</code></p> <p>Adds a new element to the NavModel immediately transitioning from <code>CREATED</code> -&gt; <code>STANDARD</code>.</p>"},{"location":"1.x/navmodel/tiles/#destroy","title":"Destroy","text":"<p><code>tiles.destroy(navTarget)</code></p> <p>Transitions a given element to <code>DESTROYED</code>.</p>"},{"location":"1.x/navmodel/tiles/#select","title":"Select","text":"<p><code>tiles.select(navTarget)</code></p> <p>Transitions a given element <code>STANDARD</code> -&gt; <code>SELECTED</code>.</p>"},{"location":"1.x/navmodel/tiles/#deselect","title":"Deselect","text":"<p><code>tiles.deselect(navTarget)</code></p> <p>Transitions a given element <code>SELECTED</code> -&gt; <code>STANDARD</code>.</p>"},{"location":"1.x/navmodel/tiles/#deselect-all","title":"Deselect all","text":"<p><code>tiles.deselectAll()</code></p> <p>Transitions all elements <code>SELECTED</code> -&gt; <code>STANDARD</code>.</p>"},{"location":"1.x/navmodel/tiles/#remove-selected","title":"Remove selected","text":"<p><code>tiles.removeSelected()</code></p> <p>Transitions all elements that have <code>SELECTED</code> state to <code>DESTROYED</code>.</p>"},{"location":"1.x/releases/changelog/","title":"Changelog","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/releases/changelog/#changelog","title":"Changelog","text":""},{"location":"1.x/releases/changelog/#pending-changes","title":"Pending changes","text":"<p>-</p>"},{"location":"1.x/releases/changelog/#130","title":"1.3.0","text":"<ul> <li>#425 \u2013 Fixed: Up navigation should be properly propagated from Appyx to RIBs</li> <li>#384 \u2013 Updated: Compose BOM version and activity-compose version</li> </ul> 22 Jun 2023"},{"location":"1.x/releases/changelog/#120","title":"1.2.0","text":"<ul> <li>#393 \u2013 Breaking change: Removed non-lazy implementations from <code>NodeCustomisationDirectory</code></li> <li>#393 \u2013 Breaking change: Removed <code>NodeCustomisationDirectoryImpl#put(vararg values: T)</code> due to potential uncaught bugs. Please call the reified <code>put</code> extension function instead.</li> </ul> 11 Apr 2023"},{"location":"1.x/releases/changelog/#112","title":"1.1.2","text":"<ul> <li>#391 \u2013 Added: Introduced <code>putLazy</code> and <code>putSubDirectoryLazy</code> functions within <code>NodeCustomisationDirectoryImpl</code> via <code>LazyMutableNodeCustomisationDirectory</code></li> </ul> 04 Apr 2023"},{"location":"1.x/releases/changelog/#111","title":"1.1.1","text":"<ul> <li>#386 \u2013 Updated: RIBs version to 0.39.0</li> </ul> 31 Mar 2023"},{"location":"1.x/releases/changelog/#110","title":"1.1.0","text":"<ul> <li>#383 \u2013 Changed: Removed deprecated methods in Node, ParentNode and CombinedHandler classes</li> <li>#376 \u2013 Changed: Androidx lifecycle version updated to 2.6.1.</li> <li>#376 \u2013 Updated: Kotlin and Compose compiler version updated to 1.8.10 to align kotlin version used in androidx lifecycle</li> <li>#375 \u2013 Fixed: SaveableStateHolder does no longer save state for destroyed elements</li> </ul> 27 Mar 2023"},{"location":"1.x/releases/changelog/#105","title":"1.0.5","text":"<ul> <li>#370 \u2013 Added: <code>RetainedInstanceStore</code> has two new functions which allows a developer to check whether an object is retained. These are: <code>isRetainedByStoreId</code> and <code>isRetained</code>.</li> </ul> 04 Mar 2023"},{"location":"1.x/releases/changelog/#104","title":"1.0.4","text":"<ul> <li>#361 \u2013 Added: Introduced <code>RetainedInstanceStore</code>. This provides developers the ability to retain objects between configuration changes.</li> <li>#336 \u2013 Updated: ChildAware API does not enforce Node subtypes only anymore, making it possible to use interfaces as public contracts for child nodes.</li> </ul> 20 Feb 2023"},{"location":"1.x/releases/changelog/#103","title":"1.0.3","text":"<ul> <li>#325 \u2013 Fixed: Crash when using PermanentChild API in View testing</li> </ul> 23 Jan 2023"},{"location":"1.x/releases/changelog/#102","title":"1.0.2","text":"<ul> <li>#287 \u2013 Added: Introduced a new <code>rememberCombinedHandler</code> implementation that takes an immutable list to avoid non-skippable compositions. The previous implementation is now deprecated.</li> <li>#287 \u2013 Added: <code>ImmutableList</code> has been added to avoid non-skippable compositions.</li> <li>#289 \u2013 Added: Introduced <code>interop-rx3</code> for RxJava 3 support. This has identical functionality to <code>interop-rx2</code>.</li> <li>#298 \u2013 Updated: ChildView documentation. <code>TransitionDescriptor</code> generics has been renamed to <code>NavTarget</code> and <code>State</code></li> <li>#307 - Added: <code>Spotlight.current()</code> method to observe currently active <code>NavTarget</code>.</li> <li>#314 \u2013 Fixed: Lifecycle is properly destroyed for suspended nodes.</li> </ul> 10 Jan 2023"},{"location":"1.x/releases/changelog/#101","title":"1.0.1","text":"<ul> <li>#268 \u2013 Fixed: <code>PermanentChild</code> now does not crash in UI tests with <code>ComposeTestRule</code>.</li> <li>#276 \u2013 Fixed: Back press handlers order is fixed for RIBs-Appyx integration.</li> <li>#272 \u2013 Changed: <code>attachWorkflow</code> renamed to <code>attachChild</code>. <code>executeWorkflow</code> renamed to <code>executeAction</code>.</li> <li>#272 \u2013 Added: <code>NodeReadyObserver</code> plugin to observe when the <code>Node</code> is ready</li> </ul> 22 Nov 2022"},{"location":"1.x/releases/changelog/#100","title":"1.0.0","text":"<ul> <li>#247 \u2013 Added: Added <code>EmptyNavModel</code> to core for cases in which a <code>ParentNode</code> only uses <code>PermanentChild</code>. The <code>DummyNavModel</code> test class is deprecated.</li> <li>#250 \u2013 Updated: Jetpack Compose to 1.3.0</li> </ul> 31 Oct 2022"},{"location":"1.x/releases/changelog/#100-rc02","title":"1.0.0-rc02","text":"<ul> <li>#231 \u2013 Fixed: Changing transition handler at runtime does not redraw children</li> <li>#239 \u2013 Fixed: Fixed an issue with desynchronisation between NavModel and children's restoration process</li> <li>#218 \u2013 Updated: <code>androidx.core:core-ktx</code> to 1.9.0.</li> </ul> 21 Oct 2022"},{"location":"1.x/releases/changelog/#100-rc01","title":"1.0.0-rc01","text":"<ul> <li>#214 \u2013 Breaking change: <code>AppyxViewTestRule</code> stops supporting automatic launching activity. Activities should be started explicitly in tests.</li> <li>#197 \u2013 Breaking change: <code>ParentNodeView</code> does not implement plugin anymore. <code>Node</code> instance is retrieved via <code>LocalComposition</code>. <code>AppyxParentViewTestRule</code> and <code>AbstractParentNodeView</code> have been removed.</li> <li>#196 \u2013 Breaking change: <code>InteropBuilder</code> now should be supplied with Appyx <code>IntegrationPointProvider</code> to attach it at the same time Appyx Node is created.</li> <li>#185 \u2013 Breaking change: <code>Activity</code> must implement <code>IntegrationPointProvider</code> and create <code>IntegrationPoint</code> manually. Weak references usage has been removed.</li> <li>#173 \u2013 Breaking change: <code>ActivityStarter</code> and <code>PermissionRequester</code> now exposes coroutine based API instead of <code>minimal.reactive</code>.</li> <li>#200 \u2013 Breaking change: Reordered the parameters for <code>ParentNode&lt;NavTarget&gt;.Child</code> and <code>fun &lt;N : Node&gt; NodeHost</code> to meet Compose guidelines.</li> <li>#43 \u2013 Updated: Jetpack Compose to <code>1.2.1</code> and Kotlin to <code>1.7.10</code>.</li> <li>#168 \u2013 Updated: Kotlin coroutines to <code>1.6.4</code>.</li> <li>#171 \u2013 Updated: RIBs to <code>0.36.1</code>.</li> <li>#212 \u2013 Updated: <code>Node</code> parent property is now public instead of private.</li> <li>#174 \u2013 Fixed: <code>IntegrationPointExample</code> does not work with \"do not keep activities\"</li> <li>#180 \u2013 Added: Ensure that <code>super.onSaveInstanceState()</code> was called to restore Node's state correctly</li> </ul> 13 Oct 2022"},{"location":"1.x/releases/changelog/#10-alpha09","title":"1.0-alpha09","text":"<ul> <li>#151 - Breaking change: Renamed <code>Routing</code> to <code>NavTarget</code>. All related namings are affected (<code>RoutingElement</code>, <code>RoutingKey</code>, etc.)</li> <li>#158 - Breaking change: Renamed <code>TransitionState</code> to <code>State</code> in all NavModel impls. Renamed <code>STASHED_IN_BACK_STACK</code> to <code>STASHED</code>.</li> <li>#146 - Breaking change: Removed <code>FragmentIntegrationPoint</code>. Clients should use <code>ActivityIntegrationPoint.getIntegrationPoint(context: Context)</code> to get integration point from Fragment</li> <li>#160 - Breaking change: Renamed <code>navmodel-addons</code> to <code>navmodel-samples</code> and stopped publishing the binary. If you feel we should add any of the samples to the main codebase, please let us know!</li> <li>#138 - Fixed: <code>androidx.appcompat:appcompat</code> from is exposed via <code>api</code> within <code>com.bumble.appyx:core</code>. This prevents potential compilation bugs.</li> <li>#143 - Fixed: Correctly exposed transitive dependencies that are part of the libraries ABI</li> <li>#162 - Fixed: <code>NodeTestHelper</code>'s <code>moveTo</code> function can now move to <code>Lifecycle.State.DESTROYED</code>. The node itself has safeguards to prevent moving from destroyed state, and moving to destroyed is a valid test case.</li> <li>#145 - Updated: <code>SpotlightSlider</code> now uses offset modifier with lambda</li> <li>#159 - Added: <code>NodeHost</code> now takes modifier parameter to decorate the view of a root node</li> <li>#162 - Added: <code>disposeOnDestroyPlugin</code> extension has been added to interop-rx2. This will allow Rx2 code to be easily disposed when the node it belongs to is destroyed.</li> <li>#161 - Added: Operations helpers</li> </ul> 22 Sep 2022"},{"location":"1.x/releases/changelog/#10-alpha08","title":"1.0-alpha08","text":"<ul> <li>#140 - Breaking change: Added <code>testing-ui-activity</code> module to avoid needing to add <code>testing-ui</code> as a debug implementation as part of instrumentation testing. See the linked issue for more details</li> <li>#139 - Fixed: <code>IntegrationPoint</code> memory leak created by <code>ActivityIntegrationPoint</code></li> </ul> 12 Sep 2022"},{"location":"1.x/releases/changelog/#10-alpha07","title":"1.0-alpha07","text":"<ul> <li>#122 - Breaking change: <code>ChildEntry.ChildMode</code> is removed, now nodes are always created when a nav model changes (previously default behaviour)</li> <li>#99 \u2013 Breaking change: Removed <code>IntegrationPointAppyxProvider</code> and made <code>ActivityIntegrationPoint</code>'s constructor private. Use <code>ActivityIntegrationPoint.createIntegrationPoint</code>. This uses a weak reference to keep track of the integration points, and will not introduce memory leaks.</li> <li>#122 - Added: New <code>ChildEntry.KeepMode</code> that allows to destroy nodes that are currently not visible on the screen</li> <li>#132 - Added: New <code>NodeComponentActivity</code> to extend when wanting to work with <code>ComponentActivity</code> as your base activity, eg when migrating from a project built from the Jetpack Compose template</li> <li>#119 - Fixed: Lifecycle observers are invoked in incorrect order (child before parent)</li> <li>#62 - Fixed: Node is marked with stable annotation making some of the composable functions skippable</li> <li>#129 - Updated: Removed sealed interface from operations to allow client to define their own</li> <li>#133 - Updated: <code>NodeView</code> interface and <code>ParentNode</code> marked as stable improving amount of skippable composables</li> </ul> 9 Sep 2022"},{"location":"1.x/releases/changelog/#10-alpha06","title":"1.0-alpha06","text":"<ul> <li>#96 \u2013 Breaking change: Removed <code>InteractorTestHelper</code>. Please use Node tests instead of Interactor tests.</li> <li>#99 \u2013 Breaking change: Modified package of <code>NodeConnector</code> and <code>Connectable</code></li> <li>#99 \u2013 Added: Source.rx2() to convert Source to io.reactivex.Observable <li>#107 \u2013 Fixed: Back press handlers are not properly registered on lifecycle events</li> 26 Aug 2022"},{"location":"1.x/releases/changelog/#10-alpha05","title":"1.0-alpha05","text":"<ul> <li>#83 \u2013 Breaking change: <code>RoutingSource</code> renamed to <code>NavModel</code>. All subclasses, fields, package names, etc., any mentions of the word follow suit.</li> <li>#91 \u2013 Fixed: Spotlight next and previous operations crash fix</li> </ul> 19 Aug 2022"},{"location":"1.x/releases/changelog/#10-alpha04","title":"1.0-alpha04","text":"<ul> <li>#39 \u2013 Added: Workflows implementation to support deeplinks</li> <li>#32 \u2013 Added: <code>BackPressHandler</code> plugin that allows to control back press behaviour via <code>androidx.activity.OnBackPressedCallback</code></li> <li>#59 \u2013 Added: interface for <code>ParentNodeView&lt;&gt;</code></li> <li>#32 \u2013 Added: Jetpack Compose Navigation code sample</li> <li>#81 \u2013 Added: Support integration point for multiple roots</li> <li>#65 \u2013 Added: <code>InteropBuilderStub</code> and <code>InteropSimpleBuilderStub</code> testing util classes</li> <li>#47 \u2013 Updated: The <code>customisations</code> module is now pure Java/Kotlin.</li> <li>#85 \u2013 Updated: Improved <code>InteropView</code> error messaging when <code>Activity</code> does not implement <code>IntegrationPointAppyxProvider</code></li> <li>#88 \u2013 Updated: Moved <code>TestUpNavigationHandler</code> to <code>testing-unit-common</code></li> </ul> 18 Aug 2022"},{"location":"1.x/releases/changelog/#10-alpha03","title":"1.0-alpha03","text":"<ul> <li>#38 \u2013 Added: JUnit5 support</li> </ul> 2 Aug 2022"},{"location":"1.x/releases/changelog/#10-alpha02","title":"1.0-alpha02","text":"<ul> <li>#19 \u2013 Fixed: Do not allow setting <code>Node.integrationPoint</code> on non-root nodes</li> <li>#23 \u2013 Fixed: Integration point attached twice crash when using live literals</li> <li>#14 \u2013 Fixed: Transition interruptions bug</li> <li>#23 \u2013 Added: Unit test support</li> <li>#26 \u2013 Added: Publish snapshot versions</li> <li>#9 \u2013 Migrated: app-tree-utils into this repository</li> </ul> 19 Jul 2022"},{"location":"1.x/releases/changelog/#10-alpha01","title":"1.0-alpha01","text":"<ul> <li>Initial release</li> </ul> 4 Jul 2022"},{"location":"1.x/releases/downloads/","title":"Downloads","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/releases/downloads/#downloads","title":"Downloads","text":""},{"location":"1.x/releases/downloads/#latest-version","title":"Latest version","text":""},{"location":"1.x/releases/downloads/#repository","title":"Repository","text":"<pre><code>repositories {\n    mavenCentral()\n}\n</code></pre>"},{"location":"1.x/releases/downloads/#core-dependencies","title":"Core dependencies","text":"<pre><code>dependencies {\n    // Core\n    implementation \"com.bumble.appyx:core:$version\"\n\n    // Test rules and utility classes for testing on Android\n    debugImplementation \"com.bumble.appyx:testing-ui-activity:$version\"\n    androidTestImplementation \"com.bumble.appyx:testing-ui:$version\"\n\n    // Utility classes for unit testing\n    testImplementation \"com.bumble.appyx:testing-unit-common:$version\"\n\n    // Test rules and utility classes for unit testing using JUnit4\n    testImplementation \"com.bumble.appyx:testing-junit4:$version\"\n\n    // Test extensions and utility classes for unit testing using JUnit5\n    testImplementation \"com.bumble.appyx:testing-junit5:$version\"\n}\n</code></pre>"},{"location":"1.x/releases/downloads/#interop-with-other-libraries","title":"Interop with other libraries","text":"<pre><code>dependencies {\n    // Optional support for RxJava 2/3\n    implementation \"com.bumble.appyx:interop-rx2:$version\"\n    implementation \"com.bumble.appyx:interop-rx3:$version\"\n\n    // Optional interoperability layer between Appyx and badoo/RIBs\n    // You have to add https://jitpack.io repository to use it because badoo/RIBs is hosted there\n    implementation \"com.bumble.appyx:interop-ribs:$version\"\n\n}\n</code></pre>"},{"location":"1.x/releases/downloads/#snapshot","title":"Snapshot","text":"<p>Snapshot version is available for all modules, use the provided repository url and <code>1-SNAPSHOT</code> version.</p> <pre><code>repositories {\n    maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }\n}\n\ndependencies {\n    implementation \"com.bumble.appyx:core:v1-SNAPSHOT\"\n}\n</code></pre>"},{"location":"1.x/ui/children-view/","title":"Children","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/ui/children-view/#adding-children-to-the-view","title":"Adding children to the view","text":"<p>Navigation models define only the abstract model, not how that model will look on the screen. This section describes different ways of adding children (navigation targets) to the composition.</p> <p>All the below mentioned composables should be added to the <code>View</code> of the parent node.</p>"},{"location":"1.x/ui/children-view/#children","title":"Children","text":"<p>Renders all visible children of a NavModel. This is the simplest and most common case.</p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\n    Children(\n        modifier = Modifier, // optional\n        navModel = TODO(),\n        transitionHandler = TODO() // optional\n    )\n}\n</code></pre> <p>When rendering children you can have access to <code>TransitionDescriptor</code> which provides the following information:</p> <pre><code>@Immutable\ndata class TransitionDescriptor&lt;NavTarget, out State&gt;(\n    val params: TransitionParams,\n    val operation: Operation&lt;NavTarget, out State&gt;,\n    val element: NavTarget,\n    val fromState: State,\n    val toState: State\n)\n</code></pre> <p>Additionally, you can supply custom modifier to a child <code>Node</code>. In this example, we're supplying different <code>Modifier</code> to a child <code>Node</code> depending on the <code>NavTarget</code>: </p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\n    Children(\n        modifier = Modifier, // optional\n        navModel = TODO(),\n        transitionHandler = TODO() // optional\n    ) {\n        children&lt;NavTarget&gt; { child, descriptor -&gt;\n            child(\n                modifier = Modifier\n                    .background(\n                        color = getBackgroundColor(descriptor.element)\n                    )\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"1.x/ui/children-view/#child","title":"Child","text":"<p>Renders a single child associated to a <code>NavElement</code>. Useful if you want to define different child placements in the layout individually. </p> <pre><code>@Composable\noverride fun View(modifier: Modifier) {\n    Child(\n        navElement = element,\n        transitionHandler = TODO()\n    ) { child, _ -&gt;\n        // TODO wrap in your own composables\n        child()\n    }\n}\n</code></pre>"},{"location":"1.x/ui/children-view/#lazy-lists-grids","title":"Lazy lists / grids","text":"<pre><code>@Composable\noverride fun View(modifier: Modifier) {\n    // TODO grab all visible children from the navModel manually\n    val children by navModel.visibleChildrenAsState()\n    GridExample(children)\n}\n\n@Composable\nprivate fun GridExample(elements: List&lt;NavElement&lt;NavTarget, out Any?&gt;&gt;) {\n    LazyVerticalGrid(\n        columns = Fixed(2),\n        modifier = Modifier.fillMaxSize(),\n        contentPadding = PaddingValues(horizontal = 16.dp),\n    ) {\n        items(elements) { element -&gt;\n            // TODO use Child composable to render them individually inside the list / grid\n            Child(navElement = element)\n        }\n    }\n}\n</code></pre>"},{"location":"1.x/ui/transitions/","title":"Transitions","text":"<p>Deprecation warning</p> <p>This page in the documentation is about Appyx <code>1.x</code>.</p> <p>Appyx is now in its <code>2.x</code> iteration.</p> <p>To access the <code>2.x</code>-related pages please check the sidebar or go to:</p> <p>Documentation root</p>"},{"location":"1.x/ui/transitions/#transitions","title":"Transitions","text":"<p>You can have arbitrary visualisations and transitions for any NavModel. For example, all of these are different representations of the same Back stack:</p> <p> </p> <p>Below you can find the different options how to visualise <code>NavModel</code> state changes. </p>"},{"location":"1.x/ui/transitions/#no-transitions","title":"No transitions","text":"<p>Using the provided Child-related composables you'll see no transitions as a default \u2013 UI changes resulting from the NavModel's state update will be rendered instantly. </p>"},{"location":"1.x/ui/transitions/#jetpack-compose-default-animations","title":"Jetpack Compose default animations","text":"<p>You can use standard Compose animations for embedded child <code>Nodes</code> in the view, e.g. <code>AnimatedVisibility</code>:</p> <pre><code>var visibility by remember { mutableStateOf(true) }\n\nChild(navElement) { child, _ -&gt;\n    AnimatedVisibility(visible = visibility) {\n        child()\n    }\n}\n</code></pre>"},{"location":"1.x/ui/transitions/#appyx-transition-handlers","title":"Appyx transition handlers","text":"<p>All the child composables provided by Appyx accept an optional <code>transitionHandler</code> argument too:</p> <ul> <li>You can use the provided ones as they're a one-liner to add \u2013 you can check the individual NavModels for the ones they come shipped with.</li> <li>You can also implement your own.</li> </ul> <p>The benefit of using transition handlers is you can represent any custom state of elements defined by your NavModel with Compose <code>Modifiers</code>.</p> <p>The example below is taken from custom navigation models. It matches custom transition states to different scaling values, and returns a <code>scale</code> <code>Modifier</code>. </p> <pre><code>class FooTransitionHandler&lt;T&gt;(\n    private val transitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n) : ModifierTransitionHandler&lt;T, Foo.State&gt;() {\n\n    // TODO define a Modifier depending on the state.\n    //  Here we'll just mutate scaling: \n    override fun createModifier(\n        modifier: Modifier,\n        transition: Transition&lt;Foo.State&gt;,\n        descriptor: TransitionDescriptor&lt;T, Foo.State&gt;\n    ): Modifier = modifier.composed {\n        val scale = transition.animateFloat(\n            transitionSpec = transitionSpec,\n            targetValueByState = {\n                when (it) {\n                    Foo.State.CREATED -&gt; 0f\n                    Foo.State.FOO -&gt; 0.33f\n                    Foo.State.BAR -&gt; 0.66f\n                    Foo.State.BAZ -&gt; 1.0f\n                    Foo.State.DESTROYED -&gt; 0f\n                }\n            })\n\n        scale(scale.value)\n    }\n}\n\n// TODO remember to add:\n@Composable\nfun &lt;T&gt; rememberFooTransitionHandler(\n    transitionSpec: TransitionSpec&lt;Foo.State, Float&gt; = { spring() }\n): ModifierTransitionHandler&lt;T, Foo.State&gt; = remember {\n    FooTransitionHandler(transitionSpec)\n}\n</code></pre>"},{"location":"1.x/ui/transitions/#more-info","title":"More info","text":"<ol> <li>You can find more complex examples in the implementations of other NavModels, such as the Promoter carousel</li> <li>You can find Codelabs tutorials that help you master custom transitions</li> <li>You can find Coding challenges related to custom transitions </li> </ol>"},{"location":"2.x/migrationguide/","title":"Appyx \u2013 Migration guide","text":""},{"location":"2.x/migrationguide/#project-organisation","title":"Project organisation","text":""},{"location":"2.x/migrationguide/#1x","title":"1.x","text":"<p>Packaged as a single library, implementing Model-driven navigation with transitions together.</p>"},{"location":"2.x/migrationguide/#2x","title":"2.x","text":"<p>The library is packaged as multiple artifacts.</p>"},{"location":"2.x/migrationguide/#appyx-navigation","title":":appyx-navigation","text":"<ul> <li>Mostly analogous to Appyx 1.0\u2019s functionality but without the transitions</li> <li>Cares about the Node structure &amp; Android-related functionality</li> <li>Uses <code>:appyx-interactions</code> as a dependency to implement navigation using gestures and transitions</li> <li>Android library</li> <li>Compose Multiplatform. </li> </ul> <p>Check also Multiplatform documentation and the <code>:demos:appyx-navigation</code> module for code examples.</p>"},{"location":"2.x/migrationguide/#appyx-interactions","title":":appyx-interactions","text":"<ul> <li>Gesture-driven, state-based motion kit &amp; transition engine</li> <li>Does not contain Node-related functionality \u2192 moved to <code>:appyx-navigation</code></li> <li>Does not contain Android-specific functionality \u2192 moved to <code>:appyx-navigation</code></li> <li>Compose Multiplatform</li> </ul>"},{"location":"2.x/migrationguide/#appyx-components","title":":appyx-components","text":"<ul> <li>Pre-packaged components to use with <code>:appyx-navigation</code></li> <li>Compose Multiplatform</li> </ul>"},{"location":"2.x/migrationguide/#rough-equivalents","title":"Rough equivalents","text":"<ul> <li>1.x \u2192 2.x</li> <li><code>NavModel</code> \u2192 <code>AppyxComponent</code></li> <li><code>TransitionHandler</code> \u2192 <code>Visualisation</code></li> <li><code>BuildContext</code> \u2192 <code>NodeContext</code></li> </ul>"},{"location":"2.x/migrationguide/#migration-guide","title":"Migration guide","text":""},{"location":"2.x/migrationguide/#gradle","title":"Gradle","text":""},{"location":"2.x/migrationguide/#core","title":"Core","text":"<p>Note that BackStack and Spotlight are now standalone artifacts. Check your usage, you might only need <code>backstack</code>:</p> <pre><code>-implementation(\"com.bumble.appyx:core:1.x.x\")\n+implementation(\"com.bumble.appyx:appyx-navigation:2.0.0-alpha01\")\n+implementation(\"com.bumble.appyx:backstack-android:2.0.0-alpha01\")\n+implementation(\"com.bumble.appyx:spotlight-android:2.0.0-alpha01\")\n</code></pre>"},{"location":"2.x/migrationguide/#testing","title":"Testing","text":"<p>Artifacts have a <code>utils-</code> prefix:</p> <pre><code>-implementation(\"com.bumble.appyx:testing-ui\")\n-implementation(\"com.bumble.appyx:testing-unit-common\")\n-implementation(\"com.bumble.appyx:testing-junit4\")\n-implementation(\"com.bumble.appyx:testing-junit5\")\n\n+implementation(\"com.bumble.appyx:utils-testing-ui\")\n+implementation(\"com.bumble.appyx:utils-testing-unit-common\")\n+implementation(\"com.bumble.appyx:utils-testing-junit4\")\n+implementation(\"com.bumble.appyx:utils-testing-junit5\")\n</code></pre>"},{"location":"2.x/migrationguide/#mainactivity","title":"MainActivity","text":"<p>If you migrate all of your codebase from 1.x to 2.x in a single go, you should skip this step. However, if you intend to keep them in parallel for a gradual migration, you must do the following:</p> <ul> <li>Update your 1.x version to <code>1.4.1-migrate-2.x</code></li> <li>Rename <code>appyxIntegrationPoint</code> usage in 1.x code to <code>appyxV1IntegrationPoint</code>:</li> </ul> <pre><code>    import com.bumble.appyx.core.integration.NodeHost\n    import com.bumble.appyx.core.integrationpoint.NodeActivity\n\n    class MainActivity : NodeActivity() {\n         super.onCreate(savedInstanceState)\n         setContent {\n             HelloAppyxTheme {\n-                NodeHost(integrationPoint = appyxIntegrationPoint) {\n+                NodeHost(integrationPoint = appyxV1IntegrationPoint) {\n                     RootNode(it)\n                 }\n             }\n     }\n</code></pre>"},{"location":"2.x/migrationguide/#usage-site-rootnode","title":"Usage site (RootNode)","text":"<pre><code>-import com.bumble.appyx.core.composable.Children\n-import com.bumble.appyx.core.modality.BuildContext\n-import com.bumble.appyx.core.node.Node\n-import com.bumble.appyx.core.node.ParentNode\n-import com.bumble.appyx.navmodel.backstack.BackStack\n-import com.bumble.appyx.navmodel.backstack.operation.push\n-import com.bumble.appyx.navmodel.backstack.transitionhandler.rememberBackstackFader\n\n+import com.bumble.appyx.components.backstack.BackStack\n+import com.bumble.appyx.components.backstack.BackStackModel\n+import com.bumble.appyx.components.backstack.operation.push\n+import com.bumble.appyx.components.backstack.ui.fader.BackStackFader\n+import com.bumble.appyx.navigation.composable.AppyxNavigationContainer\n+import com.bumble.appyx.navigation.modality.NodeContext\n+import com.bumble.appyx.navigation.node.Node\n+import com.bumble.appyx.navigation.node.ParentNode\n\nclass RootNode(\n-    buildContext: BuildContext,\n+    nodeContext: NodeContext,\n    private val backStack: BackStack&lt;NavTarget&gt; = BackStack(\n-        initialElement = Child1,\n-        savedStateMap = buildContext.savedStateMap\n+        model = BackStackModel(\n+            initialTarget = Child1,\n+            savedStateMap = nodeContext.savedStateMap\n+        ),\n+        visualisation = { BackStackFader(it) },\n     ),\n ) : ParentNode&lt;RootNode.NavTarget&gt;(\n-    navModel = backStack,\n+    appyxComponent = backStack,\n-     buildContext = buildContext\n+     nodeContext = nodeContext\n ) {\n\n    sealed class NavTarget {\n        object Child1 : NavTarget()\n        object Child2 : NavTarget()\n    }\n\n-    override fun resolve(navTarget: NavTarget, buildContext: BuildContext): Node =\n-        when (navTarget) {\n-            is Child1 -&gt; Child1Node(buildContext) { backStack.push(Child2) }\n-            is Child2 -&gt; Child2Node(buildContext)\n+    override fun buildChildNode(reference: NavTarget, nodeContext: NodeContext): Node =\n+        when (reference) {\n+            is Child1 -&gt; Child1Node(nodeContext) { backStack.push(Child2) }\n+            is Child2 -&gt; Child2Node(nodeContext)\n        }\n\n    @Composable\n    override fun Content(modifier: Modifier) {\n-        Children(\n-            navModel = backStack,\n-            transitionHandler = rememberBackstackFader(transitionSpec = { spring() }),\n+        AppyxNavigationContainer(\n+            appyxComponent = backStack,\n            modifier = Modifier.fillMaxSize()\n        )\n    }\n}\n</code></pre>"},{"location":"2.x/migrationguide/#usage-site-preview","title":"Usage site (@Preview)","text":"<pre><code>-import com.bumble.appyx.core.integration.NodeHost\n-import com.bumble.appyx.core.integrationpoint.IntegrationPointStub\n\n+import com.bumble.appyx.navigation.integration.NodeHost\n+import com.bumble.appyx.navigation.integration.IntegrationPointStub\n\n@Preview\n@Composable\nfun RootNodePreview() {\n    Box(Modifier.fillMaxSize()) {\n        NodeHost(integrationPoint = IntegrationPointStub()) {\n            RootNode(\n                nodeContext = NodeContext.root(null)\n            )\n        }\n    }\n}\n</code></pre> <p>If you have a broken import that's not listed above, please open an issue/PR, or let us know on the #appyx channel on Kotlinlang Slack. Thanks!</p>"},{"location":"components/","title":"Appyx Components","text":""},{"location":"components/#overview","title":"Overview","text":"<p>With Appyx, you can:</p> <ul> <li>Create your own components using Appyx interactions, or</li> <li>You can use the ones published by us.  </li> </ul> <p>This section focuses on the latter. Published components come in two major groups: Stable and Experimental.</p>"},{"location":"components/#stable","title":"Stable","text":"<p>Stable components are ones you can depend on in your project. We maintain them and keep their APIs stable. They might receive non-API breaking updates (e.g. new operations, or additional visualisations).</p>"},{"location":"components/#back-stack","title":"Back stack","text":"<p>A standard back stack, with multiple visualisations.</p> <p>Check its own page for more details.</p>"},{"location":"components/#spotlight","title":"Spotlight","text":"<p>A view pager-like component, with multiple visualisations.</p> <p>Check its own page for more details.</p>"},{"location":"components/#experimental","title":"Experimental","text":"<p>Experimental components are still published as artifacts, but meant only for quick prototyping, experimenting, or playing around. There's no promise they will be maintained, or that their API won't change. They might be removed at any point.</p> <p>Check its own page for more details.</p>"},{"location":"components/backstack/","title":"Back stack","text":"<p>Implements a simple linear history:</p> <ul> <li>The last element at the end of the stack is considered \"active\".</li> <li>All other elements are considered stashed.</li> <li>Children associated with stashed elements are off the screen but kept alive (see how the counter values reflect this on the video)</li> </ul> <p>The back stack can never be empty \u2013 it always contains at least one element.</p> <p>The back stack also supports different back press strategies (see further down below).</p>"},{"location":"components/backstack/#standard-visualisations","title":"Standard visualisations","text":""},{"location":"components/backstack/#slider","title":"Slider","text":"<p>Class: <code>BackStackSlider</code></p>"},{"location":"components/backstack/#parallax","title":"Parallax","text":"<p>Class: <code>BackStackParallax</code></p>"},{"location":"components/backstack/#3d-stack","title":"3D stack","text":"<p>Class: <code>BackStack3D</code></p>"},{"location":"components/backstack/#fader","title":"Fader","text":"<p>Class: <code>BackStackFader</code></p>"},{"location":"components/backstack/#custom","title":"Custom","text":"<p>You can always create your own visualisations for Appyx components. Find more info in UI representation.</p>"},{"location":"components/backstack/#modelstate","title":"ModelState","text":"<pre><code>    @Parcelize\n    data class State&lt;InteractionTarget&gt;(\n        /**\n         * Elements that have been created, but not yet moved to an active state\n         */\n        val created: Elements&lt;InteractionTarget&gt; = listOf(),\n\n        /**\n         * The currently active element.\n         * There should be only one such element in the stack.\n         */\n        val active: Element&lt;InteractionTarget&gt;,\n\n        /**\n         * Elements stashed in the back stack (history).\n         */\n        val stashed: Elements&lt;InteractionTarget&gt; = listOf(),\n\n        /**\n         * Elements that will be destroyed after reaching this state.\n         */\n        val destroyed: Elements&lt;InteractionTarget&gt; = listOf(),\n    ) : Parcelable\n</code></pre>"},{"location":"components/backstack/#constructing-the-back-stack","title":"Constructing the back stack","text":"<p>Note: As the back stack can never be empty, the initial list in the constructor must contain at  least one element.</p> <pre><code>// InteractionTarget \u2013 generic type\nsealed class InteractionTarget {\n    data class SomeElement(val someParam: Int) : InteractionTarget()\n}\n\nprivate val backStack: BackStack&lt;InteractionTarget&gt; = BackStack(\n    model = BackStackModel(\n        initialTargets = listOf(InteractionTarget.SomeElement),\n        savedStateMap = nodeContext.savedStateMap\n    ),\n    visualisation = { BackStackSlider(it) } // or other visualisations \n)\n</code></pre>"},{"location":"components/backstack/#operations","title":"Operations","text":""},{"location":"components/backstack/#push","title":"Push","text":"<p><code>backStack.push(navTarget)</code></p> <p>Effect on stack: <pre><code>[A, B, C] + Push(D) = [A, B, C, D]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>STASHED</code>. Adds a new element at the end of the stack with a <code>CREATED</code> -&gt; <code>ACTIVE</code> transition.</p>"},{"location":"components/backstack/#replace","title":"Replace","text":"<p><code>backStack.replace(navTarget)</code></p> <p>Effect on stack: <pre><code>[A, B, C] + Replace(D) = [A, B, D]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>DESTROYED</code>, which will be removed when the transition finishes. Adds a new element at the end of the stack with a <code>CREATED</code> -&gt; <code>ACTIVE</code> transition.</p>"},{"location":"components/backstack/#pop","title":"Pop","text":"<p><code>backStack.pop(navTarget)</code></p> <p>Effect on stack: <pre><code>[A, B, C] + Pop = [A, B]\n</code></pre></p> <p>Transitions the active element <code>ACTIVE</code> -&gt; <code>DESTROYED</code>, which will be removed when the transition finishes. Transitions the last stashed element <code>STASHED</code> -&gt; <code>ACTIVE</code>.</p>"},{"location":"components/backstack/#single-top","title":"Single top","text":"<p><code>backStack.singleTop(navTarget)</code></p> <p>Effect on stack: depends on the contents of the stack:</p> <pre><code>[A, B, C, D] + SingleTop(B)  = [A, B]          // of same type and equals, acts as n * Pop\n[A, B, C, D] + SingleTop(B') = [A, B']         // of same type but not equals, acts as n * Pop + Replace\n[A, B, C, D] + SingleTop(E)  = [A, B, C, D, E] // not found, acts as Push\n</code></pre>"},{"location":"components/backstack/#back-press-strategy","title":"Back press strategy","text":"<p>You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own.</p> <pre><code>class BackStack&lt;NavTarget : Any&gt;(\n    /* ... */\n    backPressHandler: BackPressHandlerStrategy&lt;NavTarget, State&gt; = PopBackPressHandler(),\n    /* ... */\n) \n</code></pre>"},{"location":"components/backstack/#popbackpresshandler","title":"PopBackPressHandler","text":"<p>The default back press handling strategy. Runs a <code>Pop</code> operation.</p>"},{"location":"components/backstack/#donthandlebackpress","title":"DontHandleBackPress","text":"<p>Serves as a no-op.</p>"},{"location":"components/experimental/","title":"Experimental","text":"<p>Other uses of the library to create complex transitions and gestures.</p>"},{"location":"components/experimental/#visualisations","title":"Visualisations","text":""},{"location":"components/experimental/#dating-cards","title":"Dating Cards","text":"<p>Class: <code>CardsVisualisation</code></p>"},{"location":"components/experimental/#puzzle-15","title":"Puzzle 15","text":"<p>Class: <code>Puzzle15Visualisation</code></p>"},{"location":"components/spotlight/","title":"Spotlight","text":"<p>Implements a mechanism analogous to a view pager; has a single active element marked by an <code>activeIndex</code> (\"it's in the spotlight\", hence the name), but unlike the back stack, it does not remove other elements.</p> <p>It's great for flows or tabbed containers.</p>"},{"location":"components/spotlight/#standard-visualisations","title":"Standard visualisations","text":""},{"location":"components/spotlight/#slider","title":"Slider","text":"<p>Class: <code>SpotlightSlider</code></p>"},{"location":"components/spotlight/#slider-scale","title":"Slider + scale","text":"<p>Class: <code>SpotlightSliderScale</code></p>"},{"location":"components/spotlight/#slider-rotation","title":"Slider + rotation","text":"<p>Class: <code>SpotlightSliderRotation</code></p>"},{"location":"components/spotlight/#3d-stack","title":"3D stack","text":"<p>Class: <code>SpotlightStack3D</code></p>"},{"location":"components/spotlight/#fader","title":"Fader","text":"<p>Class: <code>SpotlightFader</code></p>"},{"location":"components/spotlight/#custom","title":"Custom","text":"<p>You can always create your own visualisations for Appyx components. Find more info in UI representation.</p>"},{"location":"components/spotlight/#modelstate","title":"ModelState","text":"<pre><code>@Parcelize\ndata class State&lt;InteractionTarget&gt;(\n    val positions: @RawValue List&lt;Position&lt;InteractionTarget&gt;&gt;,\n    val activeIndex: Float\n) : Parcelable {\n\n    @Parcelize\n    data class Position&lt;InteractionTarget&gt;(\n        val elements: Map&lt;Element&lt;InteractionTarget&gt;, ElementState&gt; = mapOf()\n    ) : Parcelable\n\n    enum class ElementState {\n        CREATED, STANDARD, DESTROYED\n    }\n\n    fun hasPrevious(): Boolean =\n        activeIndex &gt;= 1\n\n    fun hasNext(): Boolean =\n        activeIndex &lt;= positions.lastIndex - 1\n}\n</code></pre> <p>Note that a <code>Position</code> in the list can contain multiple elements, each with their own state. This allows an element at a specific position to be destroyed (animated out) and another one to be animated in in its place.</p>"},{"location":"components/spotlight/#constructing-an-instance","title":"Constructing an instance","text":"<p>Requires defining items and an active index.</p> <pre><code>// InteractionTarget \u2013 generic type\nsealed class InteractionTarget {\n    data class SomeElement(val someParam: Int) : InteractionTarget()\n}\n\nprivate val spotlight = Spotlight(\n    model = SpotlightModel(\n        items = listOf(SomeElement(1), SomeElement(2), SomeElement(3)),\n        savedStateMap = null\n    ),\n    visualisation = { SpotlightSlider(it) }\n)\n</code></pre>"},{"location":"components/spotlight/#operations","title":"Operations","text":""},{"location":"components/spotlight/#next","title":"Next","text":"<p><code>spotlight.next()</code></p> <p>Increases the <code>activeIndex</code>.</p>"},{"location":"components/spotlight/#previous","title":"Previous","text":"<p><code>spotlight.previous()</code></p> <p>Decreases the <code>activeIndex</code>.</p>"},{"location":"components/spotlight/#first","title":"First","text":"<p><code>spotlight.first()</code></p> <p>Sets the <code>activeIndex</code> to <code>0</code>.</p>"},{"location":"components/spotlight/#last","title":"Last","text":"<p><code>spotlight.last()</code></p> <p>Sets the <code>activeIndex</code> to the maximum value.</p>"},{"location":"components/spotlight/#activate","title":"Activate","text":"<p><code>spotlight.activate(index)</code></p> <p>Sets the <code>activeIndex</code> to a specific value.</p>"},{"location":"components/spotlight/#update-elements","title":"Update elements","text":"<p><code>spotlight.updateElements(items, initialActiveIndex)</code></p> <p>Replaces elements held by the spotlight instance with a new list. Transitions:</p> <ul> <li>new elements: <code>CREATED</code> \u2192 <code>STANDARD</code></li> <li>destroyed elements: <code>STANDARD</code> \u2192 <code>DESTROYED</code>.</li> </ul>"},{"location":"interactions/","title":"Appyx Interactions \u2013 Overview","text":"<p>Component kit with gesture control for Compose Multiplatform.</p>"},{"location":"interactions/#state-driven-motion","title":"State-driven motion","text":"<p>Try this interactive sample! You can either:</p> <ul> <li>press the <code>Next</code> button, or</li> <li>\ud83d\udc46 drag the element to move it to its next state.</li> </ul> <p>How does this work?</p> <p>Appyx has a state-driven approach to UI and motion:</p> <ul> <li>The Model &amp; its UI representation are separated.</li> <li>The Model is an abstract representation that knows nothing of the UI.</li> <li>The UI is a function of the Model, and is not mutated directly.</li> <li>The Model is the single source of truth. To change the UI, we change the Model.</li> <li>All transitions and even gestures are implemented as operations acting on the Model directly.</li> </ul> <p>Let's see some of the backing code for the above example. Our model here can be in 4 possible states:</p> <pre><code>/* Code is shortened for demonstration purposes */\nclass TestDriveModel {\n\n    @Parcelize\n    data class State(\n        val elementState: ElementState\n    ) : Parcelable {\n\n        enum class ElementState {\n            A, B, C, D;\n        }\n    }\n}\n</code></pre> <p>This model is then mapped to the corresponding UI states:</p> <pre><code>@MutableUiStateSpecs\nclass TargetUiState(\n    val position: Position.Target,\n    val backgroundColor: BackgroundColor.Target,\n)\n\nprivate val topLeftCorner = TargetUiState(\n    position = Position.Target(Alignment.TopStart),\n    backgroundColor = BackgroundColor.Target(Color(0xFFFFC629))\n)\n\nprivate val topRightCorner = TargetUiState(\n    position = Position.Target(Alignment.TopEnd),\n    backgroundColor = BackgroundColor.Target(Color(0xFF353535))\n)\n\nprivate val bottomRightCorner = TargetUiState(\n    position = Position.Target(Alignment.BottomEnd),\n    backgroundColor = BackgroundColor.Target(Color(0xFFFE9763))\n)\n\nprivate val bottomLeftCorner = TargetUiState(\n    position = Position.Target(Alignment.BottomStart),\n    backgroundColor = BackgroundColor.Target(Color(0xFF855353))\n)\n\nfun ElementState.toTargetUiState(): TargetUiState =\n    when (this) {\n        A -&gt; topLeftCorner\n        B -&gt; topRightCorner\n        C -&gt; bottomRightCorner\n        D -&gt; bottomLeftCorner\n    }\n</code></pre>"},{"location":"interactions/#playing-with-the-ui-representation","title":"Playing with the UI representation","text":"<p>Let's spice up the UI representation a bit! Let's see what happens if we also associate rotation-related values with the target UI states:</p> <pre><code>@MutableUiStateSpecs\nclass TargetUiState(\n    val position: Position.Target,\n    val rotationZ: RotationZ.Target, // &lt;-- +Rotation\n    val backgroundColor: BackgroundColor.Target,\n)\n\nprivate val topLeftCorner = TargetUiState(\n    position = Position.Target(Alignment.TopStart),\n    rotationZ = RotationZ.Target(0f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFFFFC629))\n)\n\nprivate val topRightCorner = TargetUiState(\n    position = Position.Target(Alignment.TopEnd),\n    rotationZ = RotationZ.Target(180f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFF353535))\n)\n\nprivate val bottomRightCorner = TargetUiState(\n    position = Position.Target(Alignment.BottomEnd),\n    rotationZ = RotationZ.Target(270f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFFFE9763))\n)\n\nprivate val bottomLeftCorner = TargetUiState(\n    position = Position.Target(Alignment.BottomStart),\n    rotationZ = RotationZ.Target(540f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFF855353))\n)\n</code></pre> <p>Adding this new UI property will result in the below sample with no additional effort. Notice how you can still drag the element to its next state, and now the rotation is also animated automatically:</p>"},{"location":"interactions/#gestures","title":"Gestures","text":"<p>Regardless of whether a specific state change is triggered by a button press (business logic in general) or gestures (UI interaction in general), in Appyx both cases result in the same exact visual outcome.</p> <p>If you haven't tried it yet, check how both of the above examples can be manipulated by dragging as well!</p> <p>The second example demonstrates the power of Appyx's approach to gesture handling: the gesture changes the model, rather than the UI. When the state is translated to UI properties any and all additional UI parameters we added (rotation in this case) are automatically transitioned along with the gesture \u2013 no change is required in the gesture handling in client code.</p> <p>You can find more information in Gestures.</p>"},{"location":"interactions/#operation-modes","title":"Operation modes","text":"<p>Appyx supports two main operation modes: <code>Keyframe</code> and <code>Immediate</code>. The main difference is in how they handle interrupts: what should happen when new operations are triggered while a transition is already happening.</p> <p>You can achieve a very different effect by spamming the buttons a few times:</p> <p>In <code>KEYFRAME</code> mode the current transition isn\u2019t interrupted, and it will be guaranteed to finish before any additional transitions. New states are enqueued for execution afterwards. The overall execution progress speeds up proportionally to the size of enqueued operations.</p> <p>In <code>IMMEDIATE</code> mode the current transition is interrupted and will not be finished. New operations overwrite the current target state, resulting in the UI dynamically changing course always towards the latest one.</p>"},{"location":"interactions/#what-to-use-appyx-interactions-for","title":"What to use Appyx interactions for","text":"<p>Generally speaking:</p> <ol> <li>You can create just about any component that you can describe with abstract states</li> <li>Which then you can dress up with various UI representations</li> <li>And manipulate with gestures</li> </ol> <p>Check out some our packaged examples in Appyx components!</p>"},{"location":"interactions/appyxcomponent/","title":"Appyx Interactions \u2013 Creating your own components","text":""},{"location":"interactions/appyxcomponent/#overview","title":"Overview","text":"<p>A component packaged together with Appyx is called an <code>AppyxComponent</code>. It consists of:</p> <ul> <li>An abstract model representation</li> <li>One or more UI representations</li> <li>Gesture interpretation (usually \u2013 but not necessarily \u2013 tied to the UI representation)</li> </ul> <p>This section of the documentation deals with the internals of an <code>AppyxComponent</code>. If you're solely interested in using already created components, you can simply refer to Using components instead.</p> <p>The big picture:</p> <pre><code>flowchart TB\n  subgraph AC[AppyxComponent]\n    direction TB\n    T[TransitionModel] --&gt; |\"#lt;ModelState#gt;\"| V[Visualisation];\n  end\n  O[Operation] --&gt; AC --&gt; |Modifier| C([\"@Composable\"]);\n  C --&gt; |Gesture| O\n  B([Business logic]) --&gt; O</code></pre> <p>Where:</p> <ul> <li><code>TransitionModel</code> \u2013 Defines the abstract description of <code>&lt;ModelState&gt;</code>, accepts <code>Operations</code></li> <li><code>Visualisation</code> \u2013 Translates <code>&lt;ModelState&gt;</code> to UI middle representation, eventually <code>Modifier</code></li> <li><code>AppyxComponent</code> \u2013 Packages the above as a high level component; its output will result in <code>@Composable</code> elements with animated <code>Modifiers</code></li> <li><code>Operation</code> \u2013 Defines a <code>(ModelState) -&gt; ModelState</code> change</li> </ul> <p>You can read more about each in the next sections of the documentation.</p>"},{"location":"interactions/appyxcomponent/#where-to-start","title":"Where to start","text":"<p>It's recommended to extend <code>BaseAppyxComponent</code> for your implementation. You could also take a look at existing samples in the repository and use them as starting points.</p>"},{"location":"interactions/gestures/","title":"Appyx Interactions \u2013 Gestures","text":"<p>Gesture-based transitions are usually done by direct UI mutation. In Appyx, they're done by gradually mutating the abstract model instead.</p> <p>Gestures in Appyx translate to <code>Operations</code> to be executed gradually over the model state. This allows you to greatly simplify gesture-handling client code, as well as allowing gestures to result in the same exact visual outcome as any other transition between two states.</p> <p>The big picture:</p> <ol> <li>You receive information on the gesture's direction and the current model state</li> <li>Based on this, you will declare what operation the gesture corresponds to (if any)</li> <li>You will also specify which visual endpoint should the gesture complete this operation towards</li> </ol>"},{"location":"interactions/gestures/#detecting-the-gestures-direction","title":"Detecting the gesture's direction","text":"<p>Appyx comes with the following gesture-related helpers that report the direction of a drag:</p> <pre><code>/**\n * The angle of the drag such that:\n *\n * - 12 o'clock = 0 degrees\n * - 3 o'clock = 90 degrees\n */\nfun dragAngleDegrees(delta: Offset): Float\n\n/**\n * The horizontal aspect of the drag (LEFT or RIGHT), regardless of the dominant direction\n */\nfun dragHorizontalDirection(delta: Offset): Drag.HorizontalDirection\n\n/**\n * The vertical aspect of the drag (UP or DOWN), regardless of the dominant direction\n */\nfun dragVerticalDirection(delta: Offset): Drag.VerticalDirection\n\n/**\n * The dominant direction of the drag of 4 possible directions\n */\nfun dragDirection4(delta: Offset): Drag.Direction4\n\n/**\n * The dominant direction of the drag of 8 possible directions\n */\nfun dragDirection8(delta: Offset): Drag.Direction8\n\n/**\n * The drag direction interpreted on the clock\n */\nfun dragClockDirection(delta: Offset): Drag.ClockDirection\n\n\nenum class HorizontalDirection {\n    LEFT, RIGHT\n}\n\nenum class VerticalDirection {\n    UP, DOWN\n}\n\nenum class Direction4 {\n    UP, DOWN, LEFT, RIGHT\n}\n\nenum class Direction8 {\n    UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n}\n\nenum class ClockDirection(val digit: Int) {\n    Clock1(1),\n    Clock2(2),\n    Clock3(3),\n    Clock4(4),\n    Clock5(5),\n    Clock6(6),\n    Clock7(7),\n    Clock8(8),\n    Clock9(9),\n    Clock10(10),\n    Clock11(11),\n    Clock12(12)\n}\n</code></pre>"},{"location":"interactions/gestures/#gesture","title":"Gesture","text":"<p>A gesture is defined as:</p> <pre><code>open class Gesture&lt;InteractionTarget, ModelState&gt;(\n    val operation: Operation&lt;ModelState&gt;,\n    val completeAt: Offset\n)\n</code></pre> <p>It completes an Operation at a visual endpoint represented by an <code>Offset</code>. You can read about the latter further below on this page.</p>"},{"location":"interactions/gestures/#gesture-factory","title":"Gesture factory","text":"<p>A <code>GestureFactory</code> is expected to return an instance of a <code>Gesture</code> given:</p> <ul> <li>the current model state</li> <li>the drag delta of the gesture</li> <li>the density</li> </ul> <pre><code>class Gestures&lt;InteractionTarget&gt; : GestureFactory&lt;InteractionTarget, SomeModel.State&lt;InteractionTarget&gt;&gt; {\n\n    override fun createGesture(\n        state: SomeModel.State&lt;InteractionTarget&gt;,\n        delta: Offset,\n        density: Density\n    ): Gesture&lt;InteractionTarget, SomeModel.State&lt;InteractionTarget&gt;&gt; {\n        TODO()\n    }\n}\n</code></pre> <p><code>GestureFactory</code> implementations are usually nested in a specific UI representation. This makes sense since driving a model with gestures usually results in a natural UX if the gestures are in sync with what happens in the UI. However, it's not a requirement \u2013 you could use different gestures than the default one for the UI representation.</p> <p><code>GestureFactory</code> contains a Boolean field called <code>isContinuous</code> that indicates if during a drag gesture this operation completes but there's still offset to process a new gesture will be created that handles the remaining amount. This defaults to <code>true</code> however it can be overridden and changed as needed.</p>"},{"location":"interactions/gestures/#choosing-an-operation","title":"Choosing an operation","text":"<p>Let's see how the internal demo, <code>TestDrive</code> implements its gestures:</p> <p>Based on this, what we'd want is:</p> <ul> <li>If the element is in state <code>A</code>, a rightward gesture should move it to state <code>B</code></li> <li>If the element is in state <code>B</code>, a downward gesture should move it to state <code>C</code></li> <li>If the element is in state <code>C</code>, a leftward gesture should move it to state <code>D</code></li> <li>If the element is in state <code>D</code>, an upward gesture should move it to state <code>A</code></li> </ul> <p><code>TestDrive</code> already comes with an operation <code>MoveTo(private val elementState: TestDriveModel.State.ElementState)</code> that we can make use of.</p> <p>The <code>GestureFactory</code> implementation should look like this then:</p> <p><pre><code>class Gestures&lt;InteractionTarget&gt;(\n    transitionBounds: TransitionBounds,\n) : GestureFactory&lt;InteractionTarget, TestDriveModel.State&lt;InteractionTarget&gt;&gt; {\n    // We calculate these based on the offset differences between the actual TargetUiState values\n    private val widthDp = offsetB.x - offsetA.x\n    private val heightDp = offsetD.y - offsetA.y\n\n    override fun createGesture(\n        state: TestDriveModel.State&lt;InteractionTarget&gt;,\n        delta: Offset,\n        density: Density\n    ): Gesture&lt;InteractionTarget, TestDriveModel.State&lt;InteractionTarget&gt;&gt; {\n        val width = with(density) { widthDp.toPx() }\n        val height = with(density) { heightDp.toPx() }\n\n        val direction = dragDirection8(delta)\n        return when (state.elementState) {\n            A -&gt; when (direction) {\n                RIGHT -&gt; Gesture(MoveTo(B), Offset(width, 0f))\n                else -&gt; Gesture.Noop()\n            }\n            B -&gt; when (direction) {\n                DOWN -&gt; Gesture(MoveTo(C), Offset(0f, height))\n                else -&gt; Gesture.Noop()\n            }\n            C -&gt; when (direction) {\n                LEFT -&gt; Gesture(MoveTo(D), Offset(-width, 0f))\n                else -&gt; Gesture.Noop()\n            }\n            D -&gt; when (direction) {\n                UP -&gt; Gesture(MoveTo(A), Offset(0f, -height))\n                else -&gt; Gesture.Noop()\n            }\n        }\n    }\n}\n</code></pre> A more advanced version allows every state to move to each of the other 3 states. Try this sample - here you can also move the element backwards to the previous state, and also diagonally across:</p> <p>To allow this, we now handle more directions:</p> <pre><code>class Gestures&lt;InteractionTarget&gt;(\n    transitionBounds: TransitionBounds,\n) : GestureFactory&lt;InteractionTarget, TestDriveModel.State&lt;InteractionTarget&gt;&gt; {\n    private val widthDp = offsetB.x - offsetA.x\n    private val heightDp = offsetD.y - offsetA.y\n\n    override fun createGesture(\n        state: TestDriveModel.State&lt;InteractionTarget&gt;,\n        delta: Offset,\n        density: Density\n    ): Gesture&lt;InteractionTarget, TestDriveModel.State&lt;InteractionTarget&gt;&gt; {\n        val width = with(density) { widthDp.toPx() }\n        val height = with(density) { heightDp.toPx() }\n\n        val direction = dragDirection8(delta)\n        return when (state.elementState) {\n            A -&gt; when (direction) {\n                RIGHT -&gt; Gesture(MoveTo(B), Offset(width, 0f))\n                DOWNRIGHT -&gt; Gesture(MoveTo(C), Offset(width, height))\n                DOWN -&gt; Gesture(MoveTo(D), Offset(0f, height))\n                else -&gt; Gesture.Noop()\n            }\n            B -&gt; when (direction) {\n                DOWN -&gt; Gesture(MoveTo(C), Offset(0f, height))\n                DOWNLEFT -&gt; Gesture(MoveTo(D), Offset(-width, height))\n                LEFT -&gt; Gesture(MoveTo(A), Offset(-width, 0f))\n                else -&gt; Gesture.Noop()\n            }\n            C -&gt; when (direction) {\n                LEFT -&gt; Gesture(MoveTo(D), Offset(-width, 0f))\n                UPLEFT -&gt; Gesture(MoveTo(A), Offset(-width, -height))\n                UP -&gt; Gesture(MoveTo(B), Offset(0f, -height))\n                else -&gt; Gesture.Noop()\n            }\n            D -&gt; when (direction) {\n                UP -&gt; Gesture(MoveTo(A), Offset(0f, -height))\n                UPRIGHT -&gt; Gesture(MoveTo(B), Offset(width, -height))\n                RIGHT -&gt; Gesture(MoveTo(C), Offset(width, 0f))\n                else -&gt; Gesture.Noop()\n            }\n        }\n    }\n}\n</code></pre> <p>Note how whenever a direction should not result in doing anything, you can always return <code>Gesture.Noop()</code></p>"},{"location":"interactions/gestures/#visual-endpoint","title":"Visual endpoint","text":"<p>In all of the above cases we needed to pass an <code>Offset</code> as a second argument to the <code>Gesture</code>.</p> <p>Note how these offsets have different values in each case: they represent the vector from the current visual to the expected target visual state. This is the vector along which Appyx will interpret the gesture from a 0% to a 100% completion.</p> <p>For example, the vector between <code>A</code> and <code>C</code> is <code>Offset(width, height)</code> as the gesture should be completed along the downward right diagonal from <code>A</code>.</p> <p>Note that while you're not strictly required to match this offset with how an element moves on the screen, it's recommended to do so \u2013 otherwise the UX will be confusing in most cases.</p>"},{"location":"interactions/gestures/#drag-prediction","title":"Drag prediction","text":"<p>The target UI state can be rendered immediately upon starting a drag. Note how the target state here matches not only the position, but the scale and the rotation too.</p>"},{"location":"interactions/gestures/#settling-incomplete-gestures","title":"Settling incomplete gestures","text":"<p>When releasing the drag before reaching the target, the operation is settled. Depending on how far the gesture got, it might be:</p> <ul> <li>rounded up towards completion, or</li> <li>rounded down towards reverting it.</li> </ul> <p>The default threshold is <code>0.5f</code> (50%), and can be changed between <code>0f</code> (0%) and <code>1f</code> (100%). For example, a value of <code>0.2f</code> would mean the gesture would be considered completed even after a relatively short movement.</p> <p>This can be configured in <code>GestureSettleConfig</code>, along with animation specs of completion and reversal: </p> <pre><code>GestureSettleConfig(\n    completionThreshold = 0.2f, // the default is 0.5f\n    completeGestureSpec = spring(),\n    revertGestureSpec = spring(),\n)\n</code></pre> <p>Here's an example that uses a <code>completionThreshold</code> value of <code>0.15f</code> (15%). Notice that now you can release the drag much closer to the starting point and it will still complete the animation:</p>"},{"location":"interactions/gestures/#configuring-gestures-in-the-appyxcomponent","title":"Configuring gestures in the AppyxComponent","text":"<p>You can connect your gesture detection to your AppyxComponent in client code such as:</p> <pre><code>val appyxComponent = \n    SomeAppyxComponent(\n        // Required\n        model = SomeTransitionModel(/*...*/),\n        visualisation = { SomeVisualisation(/*...*/) } ,\n\n        // Optional\n        animationSpec = spring(stiffness = Spring.StiffnessLow),\n        gestureFactory = { SomeVisualisation.Gestures(/*...*/) },\n        gestureSettleConfig = GestureSettleConfig(\n            completionThreshold = 0.5f,\n            completeGestureSpec = spring(),\n            revertGestureSpec = spring(),\n        ),\n    )\n</code></pre> <p>Note that as stated above, gestures are usually come hand in hand with a specific visual representation, but you're not strictly limited to using the same ones. For example, you could use a combination of <code>SpotlightFader</code> + <code>SpotlightSlider.Gestures</code> to have cross-fading visuals controlled by swiping gestures.  </p>"},{"location":"interactions/ksp/","title":"Appyx Interactions \u2013 KSP setup","text":"<p>Defining <code>TargetUiStates</code> is easy, as demonstrated in UI representation</p> <pre><code>@MutableUiStateSpecs\nclass TargetUiState(\n    val position: Position.Target,\n    val rotation: Rotation.Target,\n    val backgroundColor: BackgroundColor.Target,\n)\n</code></pre> <p>However, for every <code>TargetUiState</code>, there needs to exist a corresponding <code>MutableUiState</code> class containing the animation code. </p> <p>By adding the <code>@MutableUiStateSpecs</code> annotation, if you follow the below setup guide, you can have the Appyx KSP mutable ui state processor generate this class for you automatically.</p>"},{"location":"interactions/ksp/#setup","title":"Setup","text":"<p>Works with Kotlin 1.8.10. For our migration to Kotlin 1.9 please check:</p> <ul> <li>#547 - Upgrade Compose Multiplatform / Kotlin</li> </ul>"},{"location":"interactions/ksp/#main-buildgradle","title":"Main <code>build.gradle</code>","text":"<pre><code>plugins {\n    id(\"com.google.devtools.ksp\") version libs.versions.ksp.get() apply false\n    // Alternatively: \n    // id(\"com.google.devtools.ksp\") version '1.8.0-1.0.8' apply false\n}\n</code></pre>"},{"location":"interactions/ksp/#app-buildgradle","title":"App <code>build.gradle</code>","text":"<pre><code>plugins {\n    id(\"com.google.devtools.ksp\") \n}\n\ncomposeOptions {\n    kotlinCompilerExtensionVersion = '1.4.3'\n}\n\ndependencies {\n    ksp(\"com.bumble.appyx:appyx-processor:{latest version}\")\n}\n</code></pre>"},{"location":"interactions/operations/","title":"Appyx Interactions \u2013 Operations","text":""},{"location":"interactions/operations/#overview","title":"Overview","text":"<p>A <code>TransitionModel</code> behaves like a state machine. If you want a new <code>ModelState</code> to be created, you must pass it an instance of an <code>Operation</code>.</p>"},{"location":"interactions/operations/#operation","title":"Operation","text":"<p>Operation defines a <code>(ModelState) -&gt; ModelState</code> change.</p> <pre><code>interface Operation&lt;ModelState&gt; {\n\n    val mode: Mode\n\n    fun isApplicable(state: ModelState): Boolean\n\n    operator fun invoke(state: ModelState): StateTransition&lt;ModelState&gt;\n}\n</code></pre>"},{"location":"interactions/operations/#operationmode","title":"Operation.Mode","text":"<p>A mode maybe specified by client code to define how the <code>TransitionModel</code> should handle the state change with regards to interrupts. </p> <pre><code>interface Operation&lt;ModelState&gt; {\n\n    enum class Mode {\n        IMMEDIATE, KEYFRAME\n    }\n}\n</code></pre> <p>You can test their effects on the below sample. Try spamming the buttons:</p> <p>In code, both buttons invoke the same operation, only with different modes:</p> <pre><code>{ testDrive.next(mode = KEYFRAME) }\n\n// vs\n\n{ testDrive.next(mode = IMMEDIATE, animationSpec = spring(\n    stiffness = Spring.StiffnessVeryLow,\n    dampingRatio = Spring.DampingRatioMediumBouncy\n)) }\n</code></pre> <p>In <code>KEYFRAME</code> mode the current transition isn\u2019t interrupted, and it will be guaranteed to finish before any additional transitions. New states are enqueued for execution afterwards. The overall execution progress speeds up proportionally to the size of enqueued operations.</p> <p>In <code>IMMEDIATE</code> mode the current transition is interrupted and will not be finished. New operations overwrite the current target state, resulting in the UI dynamically changing course always towards the latest one.</p>"},{"location":"interactions/operations/#applicability-check","title":"Applicability check","text":"<pre><code>fun isApplicable(state: ModelState): Boolean\n</code></pre> <p>This method is used for checks without actually executing an <code>Operation</code>. </p>"},{"location":"interactions/operations/#invoking-the-operation","title":"Invoking the Operation","text":"<p>This method should create a <code>StateTransition&lt;ModelState&gt;</code>:</p> <pre><code>operator fun invoke(state: ModelState): StateTransition&lt;ModelState&gt;\n</code></pre> <p>Which is defined as:</p> <pre><code>data class StateTransition&lt;ModelState&gt;(\n    val fromState: ModelState,\n    val targetState: ModelState\n)\n</code></pre> <p>It is imperative that:</p> <ol> <li><code>fromState</code> is derived from the baseline state (the one passed to <code>invoke</code>)</li> <li><code>fromState</code> adds any new elements to the state that should be animated in and are not contained in the baseline state</li> <li><code>targetState</code> is derived from <code>fromState</code> and never directly from the baseline state</li> </ol> <p>To make it easier, it is recommended to extend <code>BaseOperation</code> which helps to enforce the above:</p> <pre><code>abstract class BaseOperation&lt;ModelState&gt; : Operation&lt;ModelState&gt; {\n\n    final override fun invoke(baseLineState: ModelState): StateTransition&lt;ModelState&gt; {\n        val fromState = createFromState(baseLineState)\n        val targetState = createTargetState(fromState)\n\n        return StateTransition(\n            fromState = fromState,\n            targetState = targetState\n        )\n    }\n\n    /**\n     * @return ModelState If the operation adds any new elements to the scene,\n     *                    it MUST add them to the state here.\n     *                    Otherwise, just return baseLineState unchanged.\n     */\n    abstract fun createFromState(baseLineState: ModelState): ModelState\n\n    /**\n     * @return ModelState Any elements present in this state\n     *                    MUST also be present in the fromState already.\n     */\n    abstract fun createTargetState(fromState: ModelState): ModelState\n}\n</code></pre>"},{"location":"interactions/operations/#examples","title":"Examples","text":"<p>You can find examples for implementing operations in the repo. Some possible points of interest:</p> <ul> <li><code>TestDrive</code> / <code>MoveTo</code></li> <li><code>BackStack</code> / <code>Push</code>, <code>Pop</code>, <code>Replace</code></li> <li><code>Spotlight</code> / <code>Next</code>, <code>Prev</code>, <code>First</code>, <code>Last</code></li> </ul> <p>Notice how each of them also comes with their convenient extension methods that allow these operations to be invoked directly on their corresponding <code>AppyxComponent</code>, so that client code can use a simple API:</p> <pre><code>// Without extension methods\ntestDrive.accept(MoveTo(A))\nbackStack.accept(Pop())\nspotlight.accept(Last())\n\n// With extension methods\ntestDrive.moveTo(A)\nbackStack.pop()\nspotlight.last() \n</code></pre>"},{"location":"interactions/transitionmodel/","title":"Appyx Interactions \u2013 TransitionModel","text":""},{"location":"interactions/transitionmodel/#overview","title":"Overview","text":"<p>A <code>TransitionModel</code> defines the abstract model of the AppyxComponent.</p>"},{"location":"interactions/transitionmodel/#modelstate","title":"&lt;ModelState&gt;","text":"<p><code>TransitionModel</code> holds an instance of <code>&lt;ModelState&gt;</code>, a type defined by the implementation class.</p> <p>You can find various examples in the repository. Some possible points of interest:</p> <ul> <li><code>TestDriveModel.State</code></li> <li><code>BackStackModel.State</code></li> <li><code>SpotlightModel.State</code></li> <li><code>CardsModel.State</code></li> </ul> <p>Model state should have no knowledge of UI-related properties \u2013 all of that belongs to the UI layer. You should strive to describe your model in a semantic way that assumes nothing of its visual representation.</p> <p>For example, <code>TestDriveModel.State</code> describes an element that can be in 4 possible configurations (the example in this documentation's main page).</p> <p>Notice how the states, even though simplistic, aren't named <code>TOPLEFT</code>, <code>TOPRIGHT</code>, <code>BOTTOMRIGHT</code>, <code>BOTTOMLEFT</code>, as the positioning is only done in the UI. This allows to represent them in various different ways, without any assumptions baked in the model.  </p> <pre><code>    @Parcelize\n    data class State&lt;InteractionTarget&gt;(\n        val element: Element&lt;InteractionTarget&gt;,\n        val elementState: ElementState\n    ) : Parcelable {\n        enum class ElementState {\n            A, B, C, D;\n\n            fun next(): ElementState =\n                when (this) {\n                    A -&gt; B\n                    B -&gt; C\n                    C -&gt; D\n                    D -&gt; A\n                }\n        }\n    }\n</code></pre> <p>Another example from <code>BackStackModel.State</code>, with purely semantic naming:</p> <pre><code>    @Parcelize\n    data class State&lt;InteractionTarget&gt;(\n        /**\n         * Elements that have been created, but not yet moved to an active state\n         */\n        val created: Elements&lt;InteractionTarget&gt; = listOf(),\n\n        /**\n         * The currently active element.\n         * There should be only one such element in the stack.\n         */\n        val active: Element&lt;InteractionTarget&gt;,\n\n        /**\n         * Elements stashed in the back stack (history).\n         */\n        val stashed: Elements&lt;InteractionTarget&gt; = listOf(),\n\n        /**\n         * Elements that will be destroyed after reaching this state.\n         */\n        val destroyed: Elements&lt;InteractionTarget&gt; = listOf(),\n    ) : Parcelable\n</code></pre>"},{"location":"interactions/transitionmodel/#interactiontarget","title":"&lt;InteractionTarget&gt;","text":"<p>This generic type is simply meant for you to identify different child elements in your client code. For example, if you have a tabbed component, and each tab would be identified by a different instance of an <code>enum</code> or a <code>sealed class</code>, then this <code>enum</code> or <code>sealed class</code> would be your <code>&lt;InteractionTarget&gt;</code>.</p> <p>Then, depending on your <code>&lt;ModelState&gt;</code> and operation implementations, you can affect these targets differently.</p>"},{"location":"interactions/transitionmodel/#changing-the-state","title":"Changing the state","text":"<p>A <code>TransitionModel</code> behaves like a state machine. If you want a new <code>ModelState</code> to be created, you must pass it an instance of an <code>Operation</code>. You can read more about them in Operations. </p>"},{"location":"interactions/transitionmodel/#output","title":"Output","text":"<p><code>TransitionModel</code> has an output flow:</p> <pre><code>val output: StateFlow&lt;Output&lt;ModelState&gt;&gt;\n</code></pre> <p>In most cases don't need to deal with this output directly. The AppyxComponent takes care of that, and channels this flow to the <code>Visualisation</code> to translate it to a UI representation. </p>"},{"location":"interactions/ui-representation/","title":"Appyx Interactions \u2013 UI representation","text":""},{"location":"interactions/ui-representation/#overview","title":"Overview","text":"<p>The UI representation translates the abstract model of the TransitionModel to visual properties. </p> <p>The big picture is that you will define a set of animatable properties, such as:</p> <pre><code>@MutableUiStateSpecs\nclass TargetUiState(\n    val position: Position.Target,\n    val rotationZ: RotationZ.Target,\n    val backgroundColor: BackgroundColor.Target,\n)\n</code></pre> <p>Then you will create instances of it to represent some key states an element can be in on the UI:</p> <pre><code>private val topLeftCorner = TargetUiState(\n    position = Position.Target(Alignment.TopStart),\n    rotationZ = RotationZ.Target(0f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFFFFC629))\n)\n\nprivate val topRightCorner = TargetUiState(\n    position = Position.Target(Alignment.TopEnd),\n    rotationZ = RotationZ.Target(180f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFF353535))\n)\n\nprivate val bottomRightCorner = TargetUiState(\n    position = Position.Target(Alignment.BottomEnd),\n    rotationZ = RotationZ.Target(270f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFFFE9763))\n)\n\nprivate val bottomLeftCorner = TargetUiState(\n    position = Position.Target(Alignment.BottomStart),\n    rotationZ = RotationZ.Target(540f), // &lt;-- +Rotation\n    backgroundColor = BackgroundColor.Target(Color(0xFF855353))\n)\n</code></pre> <p>Finally, you will map all elements in your model state to instances of <code>TargetUiState</code>. In our example there's only one element:</p> <pre><code>override fun TestDriveModel.State&lt;InteractionTarget&gt;.toUiTargets(): List&lt;MatchedTargetUiState&lt;InteractionTarget, TargetUiState&gt;&gt; =\n    listOf(\n        MatchedTargetUiState(element, elementState.toTargetUiState())\n    )\n\nfun ElementState.toTargetUiState(): TargetUiState =\n    when (this) {\n        A -&gt; uiStateA\n        B -&gt; uiStateB\n        C -&gt; uiStateC\n        D -&gt; uiStateD\n    }\n</code></pre> <p>Doing so, Appyx will animate elements between these <code>TargetUiStates</code> as the abstract model changes:</p>"},{"location":"interactions/ui-representation/#a-more-detailed-view","title":"A more detailed view","text":"<p>Classes related to the UI representation:</p> <ul> <li><code>MotionProperty</code> \u2013 defines an animatable UI property</li> <li><code>MotionProperty.Target</code> \u2013 defines a target value for its own <code>MotionProperty</code></li> <li><code>TargetUiState</code> \u2013 a collection of different <code>MotionProperty.Target</code> values representing an element's desired representation</li> <li><code>MutableUiState</code> \u2013 mappable from <code>TargetUiState</code>, this class holds the transient state of animated values as they change between different targets</li> </ul>"},{"location":"interactions/ui-representation/#motionproperty","title":"MotionProperty","text":"<p>Appyx comes with a set of classes derived from <code>MotionProperty</code>. A non-exhaustive list of them:</p> <ul> <li><code>Alpha</code></li> <li><code>BackgroundColor</code></li> <li><code>Position</code></li> <li><code>RotationX</code> </li> <li><code>RotationY</code> </li> <li><code>RotationZ</code> </li> <li><code>Scale</code></li> <li><code>ZIndex</code></li> <li>etc.</li> </ul> <p>They represent UI properties that Appyx can animate. Their animated values will be automatically mapped to Compose <code>Modifier</code> instances.</p> <p>If you need a property that's not provided by Appyx, it should be very easy to create one (also consider submitting a PR).</p>"},{"location":"interactions/ui-representation/#target-values","title":"Target values","text":"<p>A <code>MotionProperty</code> is mutable towards target values. <code>Target</code> specifies such a value. They're defined by each <code>MotionProperty</code>, and are supposed to be immutable.</p> <p>For example <code>Alpha.Target</code> expects a <code>Float</code>:</p> <pre><code>class Alpha /*...*/ {\n\n    class Target(\n        val value: Float,\n        /*...*/\n    ) : MotionProperty.Target\n}\n</code></pre> <p>While <code>Position.Target</code> deals with <code>Offset</code>:</p> <pre><code>class Position /*...*/ {\n\n    class Target(\n        val value: DpOffset,\n        /*...*/\n    ) : MotionProperty.Target\n}\n</code></pre>"},{"location":"interactions/ui-representation/#targetuistate","title":"TargetUiState","text":"<p>Create your <code>TargetUiState</code> as the collection of <code>MotionProperty.Target</code> properties that you want Appyx to animate. For example, if you only want cross-fade animation, you would only need <code>Alpha</code> in your UI. Then you would define your <code>TargetUiState</code> such as:</p> <pre><code>@MutableUiStateSpecs\nclass TargetUiState(\n    val alpha: Alpha.Target,\n)\n</code></pre> <p>Or, as in the <code>TestDrive</code> example, position, rotation, and color: </p> <pre><code>@MutableUiStateSpecs\nclass TargetUiState(\n    val position: Position.Target,\n    val rotation: Rotation.Target,\n    val backgroundColor: BackgroundColor.Target,\n)\n</code></pre>"},{"location":"interactions/ui-representation/#mutableuistate","title":"MutableUiState","text":"<p>You might have noticed that the above classes are annotated with <code>@MutableUiStateSpecs</code>. Appyx comes with a KSP processor that will generate the corresponding <code>MutableUiState</code> class for you, so that you don't have to. </p> <p>Please refer to the KSP setup guide.</p>"},{"location":"interactions/ui-representation/#observing-motionproperty-in-children-ui","title":"Observing MotionProperty in children UI","text":"<p>Sometimes children UI can depend on the transition animation values. Appyx provides an API to observe <code>MotionProperty</code> inside children UI.</p> <p>In this example, children composable retrieve and display <code>DpOffset</code> value from <code>Position</code> motion property as well as <code>Float</code> value from <code>RotationY</code> using this API:</p> <pre><code>// returns dpOffset value if transition has Position MotionProperty and null otherwise \nval dpOffset : DpOffset? = motionPropertyRenderValue&lt;Position.Value, Position&gt;()?.offset\n\n// returns rotationY value if transition has RotationY MotionProperty and null otherwise \nval rotationY = motionPropertyRenderValue&lt;Float, RotationY&gt;()\n</code></pre>"},{"location":"interactions/usage/","title":"Appyx Interactions \u2013 Using components","text":""},{"location":"interactions/usage/#overview","title":"Overview","text":"<p>A component packaged together with Appyx is called an <code>AppyxComponent</code>. </p>"},{"location":"interactions/usage/#using-appyxcomponents","title":"Using AppyxComponents","text":"<p>If you're solely interested in using already created components, you don't need to learn about the internals of them. This page introduces the minimum information to get them into your Compose-based projects.</p>"},{"location":"interactions/usage/#the-big-picture","title":"The big picture","text":"<pre><code>flowchart TB\n  O[Operation] --&gt; I[AppyxComponent] --&gt; |Modifier| C([\"@Composable\"]);\n  C --&gt; |Gesture| O\n  B([Business logic]) --&gt; O</code></pre> <p>Where:</p> <ul> <li><code>AppyxComponent</code> \u2013 The packaged component; its output will result in <code>@Composable</code> elements with animated <code>Modifiers</code></li> <li><code>Operation</code> \u2013 Allows to change the state of the component. It can be triggered programmatically or by gestures. Both options are specific to the component implementation.</li> </ul>"},{"location":"interactions/usage/#instantiating-configuration","title":"Instantiating &amp; configuration","text":"<p>This section shows a generic approach that should be applicable to most components. For specific parameters and optional configuration, please refer to the actual component's own API.</p> <pre><code>@Composable\nfun SomeComposable() {\n    val appyxComponent = remember {\n        SomeAppyxComponent(\n            // List of elements, initial state, etc. go in the model:\n            model = SomeTransitionModel(/*...*/),\n\n            // The visual representation (slider, fader, etc.) \n            visualisation = { SomeVisualisation(/*...*/) } ,\n\n            // Optional \u2013 configure animations\n            animationSpec = spring(stiffness = Spring.StiffnessLow),\n\n            // What kind of gestures to control this model with \n            gestureFactory = { SomeVisualisation.Gestures(/*...*/) },\n\n            // Optional \u2013 configure behaviour of incomplete gestures\n            gestureSettleConfig = GestureSettleConfig(\n                completionThreshold = 0.2f,\n                completeGestureSpec = spring(),\n                revertGestureSpec = spring(),\n            ),\n        )\n    }\n}\n</code></pre>"},{"location":"interactions/usage/#rendering-the-appyxcomponent","title":"Rendering the AppyxComponent","text":""},{"location":"interactions/usage/#in-the-scope-of-appyx-interactions","title":"In the scope of Appyx Interactions","text":"<p>You can render your component with the <code>AppyxInteractionsContainer</code> composable. </p> <p>Make sure to:</p> <ul> <li>Apply <code>elementUiModel.modifier</code> if you override the optional <code>element</code> rendering.</li> <li>Provide <code>screenWidthPx</code> and <code>screenWidthPx</code></li> </ul> <pre><code>@Composable\nfun SomeComposable() {\n    AppyxInteractionsContainer(\n        appyxComponent = yourComponent,\n        screenWidthPx = TODO(),\n        screenHeightPx = TODO(),\n        clipToBounds = false,\n        modifier = Modifier,\n        element = { elementUiModel -&gt;\n            YourElementComposable(\n                elementUiModel = elementUiModel,\n                modifier = elementUiModel.modifier\n            )\n        }\n    )\n}\n</code></pre>"},{"location":"interactions/usage/#in-the-scope-of-appyx-navigation","title":"In the scope of Appyx Navigation","text":"<p>Appyx Navigation extends on the functionality of <code>AppyxInteractionsContainer</code> and adds <code>AppyxNavigationContainer</code> as a wrapper around it. </p> <p>For client code usage they're almost identical. However, you should always use the latter when using Appyx Navigation as it makes sure the related child <code>Nodes</code> are lifecycled properly.</p> <p>Also note:</p> <ul> <li>This composable is only accessible inside of a <code>Node</code>.</li> <li>You should use it inside the <code>View</code> composable.</li> <li>You don't need to specify screen dimensions.</li> </ul> <pre><code>class YourNode(\n    /*...*/\n) : Node&lt;T&gt; {\n\n    @Composable\n    override fun Content(modifier: Modifier) {\n        AppyxNavigationContainer(\n            appyxComponent = yourComponent,\n            modifier = modifier\n        )   \n    }\n}\n</code></pre>"},{"location":"interactions/usage/#when-to-use-which","title":"When to use which?","text":"<p>You should use <code>AppyxInteractionsContainer</code> if you're adding standalone Appyx components to your project without using navigation.</p> <p>You should always use <code>AppyxNavigationContainer</code> if you're using Appyx Navigation.</p>"},{"location":"interactions/usage/#interacting-with-the-appyxcomponent","title":"Interacting with the AppyxComponent","text":"<p>How you use your model will depend on the specific component. However, typically, you will have a high level API to trigger changes, such as:</p> <pre><code>{ backStack.pop() }\n{ spotlight.next() }\netc.\n</code></pre> <p>Models should also offer gestures to control them; please refer to their specific API documentation.</p>"},{"location":"navigation/","title":"Appyx Navigation","text":""},{"location":"navigation/#type-safe-navigation-for-compose-directly-from-code","title":"Type-safe navigation for Compose directly from code","text":"<ul> <li>Tree-based, composable</li> <li>Leverages the transitions and gesture-based capabilities of Appyx Interactions to build beautiful, custom navigation.</li> <li>Use any component for navigation, whether pre-built (Appyx Components), or custom-built by you (Appyx Interactions).</li> </ul>"},{"location":"navigation/#sample-app","title":"Sample app","text":"<p>The above is an interactive example for Appyx Navigation. You can play with it right here in the browser (try it!). You can of course launch it on mobile and desktop too.</p> <p>For more info and points of interest, make sure to check out:</p> <p>\u00bb Sample app</p>"},{"location":"navigation/#quick-start","title":"Quick start","text":"<p>Quick start guide</p>"},{"location":"navigation/#concepts","title":"Concepts","text":"<ul> <li>Model-driven navigation</li> <li>Composable navigation</li> <li>Implicit navigation</li> <li>Explicit navigation</li> </ul>"},{"location":"navigation/#features","title":"Features","text":"<ul> <li>ChildAware</li> <li>Deep link navigation</li> <li>Lifecycle</li> <li>Material 3 support</li> <li>Plugins</li> <li>Scoped DI</li> <li>Surviving configuration changes</li> </ul>"},{"location":"navigation/#integrations","title":"Integrations","text":"<ul> <li>Compose Navigation</li> <li>DI frameworks</li> <li>RIBs</li> <li>RxJava</li> <li>ViewModel</li> </ul>"},{"location":"navigation/#multiplatform","title":"Multiplatform","text":"<ul> <li>Multiplatform</li> </ul>"},{"location":"navigation/#components","title":"Components","text":"<p>See Appyx Components for Back stack, Spotlight (pager) and other components you can use in navigation.</p> <p>See Appyx Interactions on how to build your own components with state-based transitions and easy-to-create gesture control.</p>"},{"location":"navigation/multiplatform/","title":"Multiplatform","text":""},{"location":"navigation/multiplatform/#supported-platforms","title":"Supported platforms","text":""},{"location":"navigation/multiplatform/#lifecycle","title":"Lifecycle","text":"<p>Multiplatform interface:</p> <pre><code>package com.bumble.appyx.navigation.lifecycle\n\ninterface Lifecycle {\n\n    val currentState: State\n\n    val coroutineScope: CoroutineScope\n\n    fun addObserver(observer: PlatformLifecycleObserver)\n\n    fun removeObserver(observer: PlatformLifecycleObserver)\n\n    fun asFlow(): Flow&lt;State&gt;\n\n    enum class State {\n        INITIALIZED,\n        CREATED,\n        STARTED,\n        RESUMED,\n        DESTROYED,\n    }\n\n    enum class Event {\n        ON_CREATE,\n        ON_START,\n        ON_RESUME,\n        ON_PAUSE,\n        ON_STOP,\n        ON_DESTROY,\n        ON_ANY,\n    }\n}\n</code></pre> <ul> <li>On Android, it is implemented by <code>AndroidLifecycle</code>, which is backed by  <code>androidx.lifecycle</code>.</li> <li>On other platforms, it is implemented by the corresponding <code>PlatformLifecycleRegistry</code> </li> </ul>"},{"location":"navigation/multiplatform/#parcelable-parcelize-rawvalue","title":"Parcelable, Parcelize, RawValue","text":"<p>Multiplatform typealiases that are backed by their proper platform-specific ones.</p> <p>E.g. on Android:</p> <pre><code>package com.bumble.appyx.utils.multiplatform\n\nactual typealias Parcelize = kotlinx.parcelize.Parcelize\n\nactual typealias Parcelable = android.os.Parcelable\n\nactual typealias RawValue = kotlinx.parcelize.RawValue\n</code></pre>"},{"location":"navigation/multiplatform/#node-hosts","title":"Node hosts","text":"<p>The root node of an Appyx navigation tree needs to be connected to the platform. This ensures that system events (lifecycle, back press, etc.) reach your components in the tree.</p> <p>You only need to do this for the root of the tree.</p>"},{"location":"navigation/multiplatform/#android","title":"Android","text":"<pre><code>// Please note we are extending NodeActivity\nclass MainActivity : NodeActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            YourAppTheme {\n                NodeHost(\n                    lifecycle = AndroidLifecycle(LocalLifecycleOwner.current.lifecycle),\n                    integrationPoint = appyxIntegrationPoint\n                ) {\n                    RootNode(nodeContext = it)\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/multiplatform/#desktop","title":"Desktop","text":"<pre><code>fun main() = application {\n    val events: Channel&lt;Events&gt; = Channel()\n    val windowState = rememberWindowState(size = DpSize(480.dp, 640.dp))\n    val eventScope = remember { CoroutineScope(SupervisorJob() + Dispatchers.Main) }\n\n    Window(\n        state = windowState,\n        onCloseRequest = ::exitApplication,\n        onKeyEvent = {\n            // See back handling section in the docs below!    \n            onKeyEvent(it, events, eventScope) \n        },\n    ) {\n        YourAppTheme {\n            Surface(color = MaterialTheme.colorScheme.background) {\n                DesktopNodeHost(\n                    windowState = windowState,\n                    onBackPressedEvents = events.receiveAsFlow().mapNotNull {\n                        if (it is Events.OnBackPressed) Unit else null\n                    }\n                ) { \n                    RootNode(nodeContext = it)\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/multiplatform/#web","title":"Web","text":"<pre><code>fun main() {\n    val events: Channel&lt;Unit&gt; = Channel()\n    onWasmReady {\n        BrowserViewportWindow(\"Your app\") {\n            val requester = remember { FocusRequester() }\n            var hasFocus by remember { mutableStateOf(false) }\n            var screenSize by remember { mutableStateOf(ScreenSize(0.dp, 0.dp)) }\n            val eventScope = remember { CoroutineScope(SupervisorJob() + Dispatchers.Main) }\n\n            YourAppTheme {\n                Surface(\n                    color = MaterialTheme.colorScheme.background,\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .onSizeChanged { screenSize = ScreenSize(it.width.dp, it.height.dp) }\n                        .onKeyEvent {\n                            // See back handling section in the docs below!    \n                            onKeyEvent(it, events, eventScope) \n                        }\n                        .focusRequester(requester)\n                        .focusable()\n                        .onFocusChanged { hasFocus = it.hasFocus }\n                ) {\n                    WebNodeHost(\n                        screenSize = screenSize,\n                        onBackPressedEvents = events.receiveAsFlow(),\n                    ) { \n                        RootNode(nodeContext = it)\n                    }\n                }\n\n                if (!hasFocus) {\n                    LaunchedEffect(Unit) {\n                        requester.requestFocus()\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/multiplatform/#ios","title":"iOS","text":"<pre><code>val backEvents: Channel&lt;Unit&gt; = Channel()\n\nfun MainViewController() = ComposeUIViewController {\n    YourAppTheme {\n        IosNodeHost(\n            modifier = Modifier,\n            // See back handling section in the docs below!\n            onBackPressedEvents = backEvents.receiveAsFlow()\n        ) {\n            RootNode(\n               nodeContext = it\n            )\n        }\n    }\n}\n\n@Composable\nprivate fun BackButton(coroutineScope: CoroutineScope) {\n    IconButton(\n        onClick = {\n            coroutineScope.launch {\n                backEvents.send(Unit)\n            }\n        },\n        modifier = Modifier.zIndex(99f)\n    ) {\n        Icon(\n            imageVector = Icons.Default.ArrowBack,\n            tint = Color.White,\n            contentDescription = \"Go Back\"\n        )\n    }\n}\n</code></pre>"},{"location":"navigation/multiplatform/#back-handling","title":"Back handling","text":""},{"location":"navigation/multiplatform/#android_1","title":"Android","text":"<p>On Android back events are handled automatically.</p>"},{"location":"navigation/multiplatform/#desktop-web","title":"Desktop &amp; Web","text":"<p>In the above desktop and web examples there is a reference to an <code>onKeyEvent</code> method.</p> <p>You can configure any <code>KeyEvent</code> to trigger a back event via the events <code>Channel</code>. In this example the <code>OnBackPressed</code> event is launched when the backspace key is pressed down:</p> <pre><code>private fun onKeyEvent(\n    keyEvent: KeyEvent,\n    events: Channel&lt;Events&gt;,\n    coroutineScope: CoroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main),\n): Boolean =\n    when {\n        // You can also register e.g. Key.Escape instead of BackSpace: \n        keyEvent.type == KeyEventType.KeyDown &amp;&amp; keyEvent.key == Key.Backspace -&gt; {\n            coroutineScope.launch { events.send(Events.OnBackPressed) }\n            true\n        }\n\n        else -&gt; false\n    }\n</code></pre>"},{"location":"navigation/multiplatform/#ios_1","title":"iOS","text":"<p>On iOS, you can design a user interface element to enable back navigation, similar to how it's done on other platforms.  In the example mentioned earlier, we create a Composable component <code>BackButton</code> that includes an <code>ArrowBack</code> icon.  When this button is clicked, it triggers the back event through the <code>backEvents</code> <code>Channel</code>. </p>"},{"location":"navigation/multiplatform/#setting-up-the-environment-for-execution","title":"Setting up the environment for execution","text":"<p>Setting up the environment for execution</p> <p>Warning</p> <p>In order to launch the iOS target, you need a Mac with macOS to write and run iOS-specific code on simulated or real devices.</p> <p>This is an Apple requirement.</p> <p>The instructions here are tweaked and inspired from the Compose-Multiplatform-iOS template.</p> <p>To work with this project, you need the following:</p> <ul> <li>A machine running a recent version of macOS</li> <li>Xcode</li> <li>Android Studio</li> <li>Kotlin Multiplatform Mobile plugin</li> <li>CocoaPods dependency manager</li> </ul>"},{"location":"navigation/multiplatform/#check-your-environment","title":"Check your environment","text":"<p>Before you start, use the KDoctor tool to ensure that your development environment is configured correctly:</p> <ol> <li> <p>Install KDoctor with Homebrew:</p> <pre><code>brew install kdoctor\n</code></pre> </li> <li> <p>Run KDoctor in your terminal:</p> <pre><code>kdoctor\n</code></pre> </li> </ol> <p>If everything is set up correctly, you'll see valid output:</p> <pre><code>Environment diagnose (to see all details, use -v option):\n[\u2713] Operation System\n[\u2713] Java\n[\u2713] Android Studio\n[\u2713] Xcode\n[\u2713] Cocoapods\n\nConclusion:\n  \u2713 Your system is ready for Kotlin Multiplatform Mobile development!\n</code></pre> <p>Otherwise, KDoctor will highlight which parts of your setup still need to be configured and will suggest a way to fix them.</p>"},{"location":"navigation/multiplatform/#the-project-structure","title":"The project structure","text":"<p>Open the project in Android Studio and switch the view from Android to Project to see all the files and targets belonging to the project. The :demos module contains the sample target appyx-navigation.</p> <p>This module follows the standard compose multiplatform project structure:</p>"},{"location":"navigation/multiplatform/#common","title":"common","text":"<p>This is a Kotlin module that contains the logic common for Android, Desktop, iOS and web applications, that is, the code you share between platforms.</p>"},{"location":"navigation/multiplatform/#android_2","title":"android","text":"<p>This is a Kotlin module that builds into an Android application. It uses Gradle as the build system. The <code>android</code> module depends on and uses the <code>common</code> module as a regular Android library.</p>"},{"location":"navigation/multiplatform/#desktop_1","title":"desktop","text":"<p>This module builds into a Desktop application.</p>"},{"location":"navigation/multiplatform/#ios_2","title":"ios","text":"<p>This is an Xcode project that builds into an iOS application. The <code>:demos:appyx-navigation</code> module depends on and uses the <code>:demos:appyx-navigation:common</code> module as a CocoaPods dependency.</p>"},{"location":"navigation/multiplatform/#web_1","title":"web","text":"<p>This module builds into a Web app.</p>"},{"location":"navigation/multiplatform/#run-your-application","title":"Run your application","text":""},{"location":"navigation/multiplatform/#on-android","title":"On Android","text":"<p>To run your application on an Android emulator:</p> <ol> <li>Ensure you have an Android virtual device available. Otherwise, create one.</li> <li>In the list of run configurations, select <code>demos.appyx-navigation.android</code>.</li> <li>Choose your virtual/physical device and click Run.</li> </ol>"},{"location":"navigation/multiplatform/#on-ios","title":"On iOS","text":""},{"location":"navigation/multiplatform/#running-on-a-simulator","title":"Running on a simulator","text":"<p>To run your application on an iOS simulator in Android Studio, modify the <code>iOS</code> run configuration:</p> <ol> <li>In the list of run configurations, select Edit Configurations:</li> <li>Navigate to iOS Application | iosApp.</li> <li>Select the desired <code>.xcworkspace</code> file under <code>XCode project file</code> which can be found in <code>/demos/appyx-navigation/iosApp/iosApp.xcworkspace</code>.</li> <li>Ensure <code>Xcode project scheme</code> is set to <code>iosApp</code>.</li> <li>In the Execution target list, select your target device. Click OK.</li> <li>The <code>iosApp</code> run configuration is now available. Click Run next to your virtual device.</li> </ol>"},{"location":"navigation/multiplatform/#running-on-a-real-device","title":"Running on a real device","text":"<p>To run the Compose Multiplatform application on a real iOS device. You'll need the following:</p> <ul> <li>The <code>TEAM_ID</code> associated with your Apple ID</li> <li>The iOS device registered in Xcode</li> </ul>"},{"location":"navigation/multiplatform/#finding-your-team-id","title":"Finding your Team ID","text":"<p>In the terminal, run <code>kdoctor --team-ids</code> to find your Team ID. KDoctor will list all Team IDs currently configured on your system.</p> <p>To run the application, set the <code>TEAM_ID</code>:</p> <ol> <li>In the project, navigate to the <code>iosApp/Configuration/Config.xcconfig</code> file.</li> <li>Set your <code>TEAM_ID</code>.</li> <li>Re-open the project in Android Studio. It should show the registered iOS device in the <code>iosApp</code> run configuration.</li> </ol>"},{"location":"navigation/multiplatform/#on-desktop","title":"On Desktop","text":"<p>To run the application as a JVM target on desktop:</p> <ol> <li>In the list of run configurations, select Edit Configurations.</li> <li>Click Add new configuration and select Gradle.</li> <li>Set <code>run</code> configuration under <code>Run</code>.</li> <li>Select the desired target under <code>Gradle project</code> to be executed (for example: <code>appyx:demos:appyx-navigation:desktop</code>).</li> <li>The desktop configuration for the desired target is now available. Click Run to execute.</li> </ol>"},{"location":"navigation/multiplatform/#on-web","title":"On Web","text":"<p>To run the application on web:</p> <ol> <li>In the list of run configurations, select Edit Configurations.</li> <li>Click Add new configuration and select Gradle.</li> <li>Set <code>jsBrowserDevelopmentRun</code> under <code>Run</code>.</li> <li>Select the desired target under <code>Gradle project</code> to be executed (for example: <code>appyx:demos:appyx-navigation:web</code>).</li> <li>The web configuration for the desired target is now available. Click Run to execute.</li> </ol>"},{"location":"navigation/quick-start/","title":"Quick start guide","text":"<p>You can check out Composable navigation, which explains the concepts you'll encounter in this guide.</p>"},{"location":"navigation/quick-start/#the-scope-of-this-guide","title":"The scope of this guide","text":"<p>The steps below will cover:</p> <ol> <li>Integrating Appyx into your project</li> <li>Creating a very simple <code>Node</code> hierarchy</li> <li>We'll use a simple back stack for navigation</li> <li>We'll see how to change transition animations easily</li> </ol> <p>This should be enough to get you started as a rudimentary application structure.</p>"},{"location":"navigation/quick-start/#1-add-appyx-to-your-project","title":"1. Add Appyx to your project","text":"<p>Please refer to the Downloads to find the relevant artifacts (also depending on whether you're doing this in a multiplatform project or not).</p> <p>For the scope of this quick start guide, you will need to add dependencies for:</p> <ul> <li>Appyx Navigation</li> <li>Back stack</li> </ul>"},{"location":"navigation/quick-start/#2-create-a-root-node","title":"2. Create a root Node","text":"<pre><code>class RootNode(\n    nodeContext: NodeContext\n) : LeafNode(\n    nodeContext = nodeContext\n) {\n    @Composable\n    override fun Content(modifier: Modifier) {\n        Text(\"Hello world!\")\n    }\n}\n</code></pre>"},{"location":"navigation/quick-start/#3-connect-to-your-platform","title":"3. Connect to your platform","text":"<p>Plug your root node into your platform: Multiplatform | Node hosts.</p> <p>Use the multiplatform imports Appyx provides in any of the code snippets from now on, such as: </p> <pre><code>import com.bumble.appyx.utils.multiplatform.Parcelable\nimport com.bumble.appyx.utils.multiplatform.Parcelize\nimport com.bumble.appyx.utils.multiplatform.RawValue\n</code></pre>"},{"location":"navigation/quick-start/#4-define-children","title":"4. Define children","text":"<p>A single leaf node isn't all that interesting. Let's add some children to the root!</p> <p>First, let's define the possible set of children using a sealed class. We'll refer them via these navigation targets:</p> <pre><code>import com.bumble.appyx.utils.multiplatform.Parcelable\nimport com.bumble.appyx.utils.multiplatform.Parcelize\n\n/**\n * You can create this class inside the body of RootNode\n * \n * Note: You must apply the 'kotlin-parcelize' plugin to use @Parcelize\n * https://developer.android.com/kotlin/parcelize\n */\nsealed class NavTarget : Parcelable {\n    @Parcelize\n    object Child1 : NavTarget()\n\n    @Parcelize\n    object Child2 : NavTarget()\n\n    @Parcelize\n    object Child3 : NavTarget()\n}\n</code></pre> <p>Next, let's modify <code>RootNode</code> so it extends <code>Node</code> instead of <code>LeafNode</code>:</p> <pre><code>class RootNode(\n    nodeContext: NodeContext\n) : Node&lt;NavTarget&gt;(\n    appyxComponent = TODO(\"We will come back to this in Step 5\"),\n    nodeContext = nodeContext\n) {\n</code></pre> <p><code>Node</code> expects us to implement the abstract method <code>buildChildNode</code>. This is how we relate navigation targets to actual children. Let's use these helper methods to define some placeholders for the time being \u2013 we'll soon make them more appealing:</p> <pre><code>override fun buildChildNode(reference: NavTarget, nodeContext: NodeContext): Node =\n    when (reference) {\n        NavTarget.Child1 -&gt; node(nodeContext) { Text(text = \"Placeholder for child 1\") }\n        NavTarget.Child2 -&gt; node(nodeContext) { Text(text = \"Placeholder for child 2\") } \n        NavTarget.Child3 -&gt; node(nodeContext) { Text(text = \"Placeholder for child 3\") }\n    }\n</code></pre> <p>Great! With this mapping created, we can now just refer to children using the sealed class elements, and Appyx will be able to relate them to other nodes.</p>"},{"location":"navigation/quick-start/#5-add-a-back-stack","title":"5. Add a back stack","text":"<p>The project wouldn't compile just yet. <code>Node</code> expects us to pass an instance of an <code>AppyxComponent</code> \u2013 the main control structure in any case when we want to add children. No need to worry now \u2013 for simplicity, let's just go with a simple <code>BackStack</code> implementation here:</p> <pre><code>class RootNode(\n    nodeContext: NodeContext,\n    private val backStack: BackStack&lt;NavTarget&gt; = BackStack(\n        model = BackStackModel(\n            initialTarget = NavTarget.Child1,\n            savedStateMap = nodeContext.savedStateMap,        \n        ),\n        visualisation = { BackStackFader(it) }\n    )\n) : Node&lt;NavTarget&gt;(\n    nodeContext = nodeContext,\n    appyxComponent = backStack // pass it here\n) {\n</code></pre> <p>With this simple addition we've immediately gained a lot of power! Now we can use the back stack's API to add, replace, pop children with operations like:</p> <pre><code>backStack.push(NavTarget.Child2)    // will add a new navigation target to the end of the stack and make it active \nbackStack.replace(NavTarget.Child3) // will replace the currently active child\nbackStack.pop()                     // will remove the currently active child and restore the one before it\n</code></pre> <p>Since we passed the back stack to the <code>Node</code>, all such changes will be immediately reflected. We only need to add it to the composition:</p> <pre><code>@Composable\noverride fun Content(modifier: Modifier) {\n    Column(\n        modifier = modifier\n    ) {\n        // Let's include the elements of our component into the composition\n        AppyxNavigationContainer(\n            appyxComponent = backStack,\n            modifier = Modifier.weight(0.9f)\n        )\n\n        // Let's also add some controls so we can test it\n        Row(\n            horizontalArrangement = Arrangement.Center,\n            modifier = Modifier\n                .fillMaxWidth()\n                .weight(0.1f)\n        ) {\n            TextButton(onClick = { backStack.push(NavTarget.Child1) }) {\n                Text(text = \"Push child 1\")\n            }\n            TextButton(onClick = { backStack.push(NavTarget.Child2) }) {\n                Text(text = \"Push child 2\")\n            }\n            TextButton(onClick = { backStack.push(NavTarget.Child3) }) {\n                Text(text = \"Push child 3\")\n            }\n            TextButton(onClick = { backStack.pop() }) {\n                Text(text = \"Pop\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/quick-start/#6-visualisations-transitions","title":"6. Visualisations, transitions","text":"<p>Adding a different visual representation of our model and its state changes is as simple as changing this:</p> <pre><code>visualisation = { BackStackFader(it) }\n</code></pre> <p>to this:</p> <pre><code>visualisation = { BackStackSlider(it) }\n</code></pre> <p>or this:</p> <pre><code>visualisation = { BackStackParallax(it) }\n</code></pre> <p>or this:</p> <pre><code>visualisation = { BackStack3D(it) }\n</code></pre> <p>Be sure to check the Back stack documentation where you can also find live previews of the above visualisations.</p> <p>Need something more custom?</p> <ol> <li>You can create your own visualisations.</li> <li>Instead of a back stack, you can also find other Components in the library, or you can create your own.</li> </ol>"},{"location":"navigation/quick-start/#7-proper-child-nodes","title":"7. Proper child nodes","text":"<p>As a last step, let's replace at least one of the child placeholders with another proper node.</p> <p>Let's create a dedicated class:</p> <pre><code>class SomeChildNode(\n    nodeContext: NodeContext\n) : Node(\n    nodeContext = nodeContext\n) {\n    @Composable\n    override fun Content(modifier: Modifier) {\n        Text(\"This is SomeChildNode\")\n    }\n}\n</code></pre> <p>Now we can update the <code>buildChildNode</code> method in <code>RootNode</code> so that the target <code>Child3</code> refers to this node. It should work out of the box:</p> <pre><code>override fun buildChildNode(reference: NavTarget, nodeContext: NodeContext): Node =\n    when (reference) {\n        NavTarget.Child1 -&gt; node(nodeContext) { Text(text = \"Placeholder for child 1\") }\n        NavTarget.Child2 -&gt; node(nodeContext) { Text(text = \"Placeholder for child 2\") } \n        NavTarget.Child3 -&gt; SomeChildNode(nodeContext)\n    }\n</code></pre>"},{"location":"navigation/quick-start/#whats-next","title":"What's next?","text":"<p>Congrats, you've just built your first Appyx tree!</p> <p>You can repeat the same pattern and make any embedded children also a <code>Node</code> with their own children, navigation models, and transitions. As complexity grows, generally you would:</p> <ol> <li>Have a <code>LeafNode</code></li> <li>At some point make it a <code>Node</code> and add children to it</li> <li>At some point extract the increasing complexity from a placeholder to another <code>LeafNode</code> </li> <li>Repeat the same on children, go to <code>1.</code></li> </ol>"},{"location":"navigation/quick-start/#further-reading","title":"Further reading","text":"<ul> <li>Check out Model-driven navigation how to take your navigation to the next level</li> <li>You can (and probably should) also extract local business logic, the view, any any other components into separate classes and Plugins.</li> </ul>"},{"location":"navigation/sample-app/","title":"Appyx Navigation \u2013 Sample app","text":"<p>You can try out the app right here in the browser. The above example is interactive!</p>"},{"location":"navigation/sample-app/#multiplatform","title":"Multiplatform","text":"<p>Check out the <code>:demos:appyx-navigation</code> module in the project (see on GitHub) to launch platform-specific variants.</p>"},{"location":"navigation/sample-app/#points-of-interest","title":"Points of interest","text":"<p>You can experiment with the following in the sample app:</p>"},{"location":"navigation/sample-app/#gestures-transitions","title":"Gestures &amp; transitions","text":"<ul> <li>Swipe left-right in the cake pager</li> <li>Tap on any cake to enter or exit hero mode</li> <li>Swipe left-right while in hero mode</li> <li>Swipe up-down between hero and list mode for a gradual transition</li> </ul>"},{"location":"navigation/sample-app/#remote-triggered-transitions","title":"Remote triggered transitions","text":"<p>In the app:</p> <ul> <li>Go to Home, tap the <code>Go to a random cake</code> button</li> </ul> <p>Trigger via deep link (basic):</p> <ul> <li>Android: <code>adb shell am start -a \"android.intent.action.VIEW\" -d \"appyx://randomcake\"</code></li> <li>iOS: <code>xcrun simctl openurl booted 'appyx://randomcake'</code></li> </ul> <p>Trigger via deep link (advanced, waits for user to finish logging in):</p> <ol> <li>Go to <code>Profile</code> in the bottom menu, tap <code>Log out</code></li> <li>Close the app </li> <li>Trigger the deep link<ul> <li>Android: <code>adb shell am start -a \"android.intent.action.VIEW\" -d \"appyx://randomcake-wait\"</code></li> <li>iOS: <code>xcrun simctl openurl booted 'appyx://randomcake-wait'</code></li> </ul> </li> <li>Tap <code>Log in</code> and see the deep link action resume</li> </ol>"},{"location":"navigation/sample-app/#scoped-dependencies","title":"Scoped dependencies","text":"<p>The cart object lives inside the <code>MainNode</code>. It's the same instance passed to all child nodes in the tree, but is destroyed when logging out and logging back in. Try:</p> <ul> <li>Add items to cart, log out from <code>Profile</code>, log back in</li> <li>Add items to cart, go to checkout, manipulate cart, finish checkout flow</li> </ul>"},{"location":"navigation/sample-app/#other","title":"Other","text":"<ul> <li>Resize window (desktop or standalone launched web) to see the Material 3 Navigation Bar automatically switches to a Navigation Rail depending on screen size.</li> </ul>"},{"location":"navigation/sample-app/#relevant-pages-from-the-documentation","title":"Relevant pages from the documentation","text":""},{"location":"navigation/sample-app/#concepts","title":"Concepts","text":"<p>Topics on how the sample app is put together, and how navigation works in it: </p> <ul> <li>Model-driven navigation</li> <li>Composable navigation</li> <li>Implicit navigation</li> <li>Explicit navigation</li> </ul>"},{"location":"navigation/sample-app/#features","title":"Features","text":"<p>Library features used in the app:</p> <ul> <li>Deep link navigation</li> <li>Material 3 support</li> <li>Scoped DI</li> <li>Surviving configuration changes</li> </ul>"},{"location":"navigation/sample-app/#whats-behind-the-custom-component","title":"What's behind the custom component","text":"<p>The cake slider / hero transition is a custom component. Check these out on how it's put together:</p> <ul> <li>Code</li> <li>Appyx Interactions intro</li> <li>Creating custom components with Appyx Interactions</li> </ul>"},{"location":"navigation/concepts/composable-navigation/","title":"Composable navigation","text":"<p>AppyxComponents in Appyx are composable. </p> <p>As a single <code>AppyxComponent</code> won't be enough for the whole of your whole app, you can use many in a composable way. That is, any managed element of a <code>AppyxComponent</code> can also host its own <code>AppyxComponent</code>.</p>"},{"location":"navigation/concepts/composable-navigation/#nodes-structural-elements-for-composing-navigation","title":"Nodes \u2013 structural elements for composing navigation","text":"<p><code>Nodes</code> are the main structural element in Appyx. They can form a tree.</p> <p>You can think of a <code>Node</code> as a standalone unit of your app with:</p> <ul> <li>Its own <code>AppyxComponent</code></li> <li>Its own Lifecycle</li> <li>State restoration</li> <li>A <code>@Composable</code> view</li> <li>Business logic that's kept alive even when the view isn't added to the composition</li> <li>The ability to host generic Plugins to extract extra concerns without enforcing any particular architectural pattern</li> </ul> <p>This allows you to make your app's business logic also composable by leveraging <code>Nodes</code> as lifecycled components.</p>"},{"location":"navigation/concepts/composable-navigation/#parent-nodes-child-nodes","title":"Parent nodes, child nodes","text":"<p><code>Nodes</code> can have other <code>Nodes</code> as children. This means you can represent your whole application as a tree of Appyx nodes.</p> <p></p> <p>You can go as granular or as high-level as it fits you. This allows to keep the complexity low in individual <code>Nodes</code> by extracting responsibilities to children, as well as composing other components to build more complex functionality.</p>"},{"location":"navigation/concepts/composable-navigation/#childaware-api","title":"ChildAware API","text":"<p>A <code>Node</code> can react to dynamically added child <code>Nodes</code> in the tree: ChildAware API</p>"},{"location":"navigation/concepts/composable-navigation/#navigation-in-the-tree","title":"Navigation in the tree","text":"<p>Once you've structured your navigation in a composable way, you can add an <code>AppyxComponent</code> to a <code>Node</code> of this tree and make it dynamic:</p> <ul> <li>Some parts in this tree are active while others ore not</li> <li>The active parts define what state the application is in, and what the user sees on the screen</li> <li>We can change what's active by using an <code>AppyxComponent</code> on each level of the tree</li> <li>Changes will feel like navigation to the user</li> </ul> <p>See Implicit navigation and Explicit navigation for building complex navigation behaviours with this approach.</p>"},{"location":"navigation/concepts/composable-navigation/#how-appyxcomponents-affect-nodes","title":"How AppyxComponents affect Nodes","text":"<p><code>AppyxComponent</code> operations will typically result in:</p> <ul> <li>Adding or removing child <code>Nodes</code> of a <code>Node</code></li> <li>Move them on and off the screen</li> <li>Change their states</li> </ul> <p>As an illustration:</p> <p> </p> <p>Here:</p> <ul> <li><code>Back stack</code> illustrates adding and removing child <code>Nodes</code></li> <li><code>Tiles</code> illustrates changing the state of children and removing them from the <code>Node</code></li> </ul> <p>These are just two examples, you're of course not limited to using them.</p>"},{"location":"navigation/concepts/composable-navigation/#summary","title":"Summary","text":"<p>A summary of Appyx's approach to structuring applications:</p> <ul> <li>Compose your app out of <code>Nodes</code> with their own lifecycles and state</li> <li>Navigation is local, composed of individual pieces of <code>AppyxComponents</code></li> <li>Navigation is stateful</li> <li>Navigation is unit-testable</li> <li>Nested navigation and multi-module navigation works as a default</li> <li>You're free to implement your own navigable components by utilising <code>AppyxComponents</code></li> <li>Avoid global navigation concerns, like shared modules needing to know about the application, or the application needing to know about all its possible modules</li> </ul>"},{"location":"navigation/concepts/explicit-navigation/","title":"Explicit navigation","text":"<p>When Implicit navigation doesn't fit your use case, you can try an explicit approach.</p> <p>Relevant methods</p> <ul> <li>Node.attachChild()</li> <li>Node.waitForChildAttached()</li> </ul> <p>Using these methods we can chain together a path which leads from the root of the tree to a specific <code>Node</code>.</p>"},{"location":"navigation/concepts/explicit-navigation/#use-case","title":"Use case","text":"<p>We want to navigate from <code>Chat</code></p> <p></p> <p>to onboarding's first screen <code>O1</code>:</p> <p></p> <p>This time we'll want to do this explicitly by calling a function.</p>"},{"location":"navigation/concepts/explicit-navigation/#the-plan","title":"The plan","text":"<ol> <li>Create a public method on <code>Root</code> that attaches <code>Onboarding</code></li> <li>Create a public method on <code>Onboarding</code> that attaches the first onboarding screen</li> <li>Create a <code>Navigator</code>, that starting from an instance of <code>Root</code>, can chain these public methods together into a single action: <code>navigateToO1()</code></li> <li>Capture an instance of <code>Root</code> to use with <code>Navigator</code></li> <li>Call <code>navigateToO1()</code> on our <code>Navigator</code> instance</li> </ol>"},{"location":"navigation/concepts/explicit-navigation/#step-1-root-onboarding","title":"Step 1 \u2013 <code>Root</code> \u2192 <code>Onboarding</code>","text":"<p>First, we need to define how to programmatically attach <code>Onboarding</code> to the <code>Root</code>:</p> <pre><code>class RootNode(\n    nodeContext: NodeContext,\n    backStack: BackStack&lt;NavTarget&gt;\n) : Node&lt;NavTarget&gt;(\n    nodeContext = nodeContext,\n    appyxComponent = backStack,\n) {\n\n    suspend fun attachOnboarding(): OnboardingNode {\n        return attachChild {\n            backStack.replace(NavTarget.Onboarding)\n        }\n    }\n}\n</code></pre> <p>Let's break down what happens here:</p> <ol> <li>Since <code>attachChild</code> has a generic <code>&lt;T&gt;</code> return type, it will conform to the defined <code>OnboardingNode</code> type </li> <li>However, <code>attachChild</code> doesn't know how to create navigation to <code>OnboardingNode</code> \u2013 that's something only we can do with the provided lambda</li> <li>We replace <code>NavTarget.Onboarding</code> into the back stack</li> <li>Doing this should result in <code>OnboardingNode</code> being created and added to <code>RootNode</code> as a child </li> <li><code>attachChild</code> expects an instance of <code>OnboardingNode</code> to appear as a child of <code>Root</code> as a consequence of executing our lambda</li> <li>Once it appears, <code>attachChild</code> returns it</li> </ol> <p>Important</p> <p>It's our responsibility to make sure that the provided lambda actually results in the expected child being added. If we accidentally do something else instead, for example:</p> <pre><code>suspend fun attachOnboarding(): OnboardingNode {\n    return attachChild {\n        backStack.replace(NavTarget.Main) // Wrong NavTarget\n    }\n}\n</code></pre> <p>Then an exception will be thrown after a timeout.</p>"},{"location":"navigation/concepts/explicit-navigation/#step-2-onboarding-o1","title":"Step 2 \u2013 <code>Onboarding</code> \u2192 <code>O1</code>","text":"<p>Unlike <code>Root</code>, <code>Onboarding</code> uses Spotlight instead of BackStack as an <code>AppyxComponent</code>, so navigation to the first screen is slightly different:  </p> <pre><code>class OnboardingNode(\n    nodeContext: NodeContext,\n    spotlight: Spotlight&lt;NavTarget&gt;\n) : Node&lt;NavTarget&gt;(\n    nodeContext = nodeContext,\n    appyxComponent = spotlight,\n) {\n\n    suspend fun attachO1(): O1Node {\n        return attachChild {\n            spotlight.activate(index = 0)\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/concepts/explicit-navigation/#step-3-our-navigator","title":"Step 3 \u2013 Our <code>Navigator</code>","text":"<pre><code>interface Navigator {\n     fun navigateToO1()\n}\n</code></pre> <p>In this case we'll implement it directly with our activity:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n    lateinit var rootNode: RootNode // See the next step\n\n     override fun navigateToO1() {\n         lifecycleScope.launch {\n             rootNode\n                 .attachOnboarding()\n                 .attachO1()\n         }\n     }\n}\n</code></pre>"},{"location":"navigation/concepts/explicit-navigation/#step-4-an-instance-of-rootnode","title":"Step 4 \u2013 An instance of <code>RootNode</code>","text":"<p>As the last piece of the puzzle, we'll also need to capture the instance of <code>RootNode</code> to make it all work. We can do that by a <code>NodeReadyObserver</code> plugin when setting up our tree:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n    lateinit var rootNode: RootNode\n\n    override fun navigateToO1() { /*...*/ }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            NodeHost(integrationPoint = appyxIntegrationPoint) {\n                RootNode(\n                    nodeContext = it,\n                    navigator = this@ExplicitNavigationExampleActivity,\n                    plugins = listOf(object : NodeReadyObserver&lt;RootNode&gt; {\n                        override fun init(node: RootNode) {\n                            rootNode = node\n                        }\n                    })\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/concepts/explicit-navigation/#step-5-using-the-navigator","title":"Step 5 \u2013 Using the <code>Navigator</code>","text":"<p>See how in the previous snippet <code>RootNode</code> receives a <code>navigator</code> dependency. </p> <p>It can pass it further down the tree as a dependency to other nodes. Those nodes can call the methods of the <code>Navigator</code>, which will change the global navigation state directly.</p>"},{"location":"navigation/concepts/explicit-navigation/#bonus-wait-for-a-child-to-be-attached","title":"Bonus: Wait for a child to be attached","text":"<p>There might be cases when we want to wait for a certain action to be performed by the user, rather than us, to result in a child being attached.</p> <p>In these cases we can use <code>Node.waitForChildAttached()</code> instead.</p>"},{"location":"navigation/concepts/explicit-navigation/#use-case-wait-for-login","title":"Use case \u2013 Wait for login","text":"<p>A typical case building an explicit navigation chain that relies on <code>Logged in</code> being attached. Most probably <code>Logged in</code> has a dependency on some kind of a <code>User</code> object. Here we want to wait for the user to authenticate themselves, rather than creating a dummy user object ourselves.</p> <pre><code>class RootNode(\n    nodeContext: NodeContext,\n) : Node&lt;NavTarget&gt;(\n    nodeContext = nodeContext\n) {\n\n    suspend fun waitForLoggedIn(): LoggedInNode = \n        waitForChildAttached&lt;LoggedInNode&gt;()\n}\n</code></pre> <p>This method will wait for <code>LoggedInNode</code> to appear in the child list of <code>RootNode</code> and return with it. If it's already there, it returns immediately.</p> <p>A navigation chain using it could look like:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n     override fun navigateToProfile() {\n         lifecycleScope.launch {\n             rootNode\n                 .waitForLoggedIn()\n                 .attachMain()\n                 .attachProfile()\n         }\n     }\n}\n</code></pre> <p>You can find related code examples in <code>ExplicitNavigationExampleActivity</code> in our samples.</p>"},{"location":"navigation/concepts/implicit-navigation/","title":"Implicit navigation","text":"<p>How can we go from one part of the tree to another? In almost all cases navigation can be implicit instead of explicit. We don't need to specify the target \u2013 navigation will happen as a consequence of individual pieces of the puzzle.</p> <p>Relevant methods</p> <ul> <li><code>Node.onChildFinished(child: Node)</code> can be overridden by client code to handle a child finishing</li> <li><code>Node.finish()</code> invokes the above method on its parent</li> </ul>"},{"location":"navigation/concepts/implicit-navigation/#use-case-1","title":"Use-case 1","text":""},{"location":"navigation/concepts/implicit-navigation/#requirement","title":"Requirement","text":"<p>After onboarding finishes, the user should land in the message list screen.</p>"},{"location":"navigation/concepts/implicit-navigation/#solution","title":"Solution","text":"<ol> <li><code>O3</code> calls its <code>finish()</code> method</li> <li><code>Onboarding</code> notices <code>O3</code> finished; if it had more children, it could switch to another; now it calls <code>finish()</code> too</li> <li><code>Logged in</code> notices <code>Onboarding</code> finished, and switches its navigation to <code>Main</code></li> <li><code>Main</code> is initialised, and loads its default navigation target (based on product requirements) to be <code>Messages</code></li> <li><code>Messages</code> is initialised, and loads its default navigation target to be <code>List</code></li> </ol> <p>Bonus</p> <p>Every <code>Node</code> in the above sequence only needed to care about its own local concern.</p>"},{"location":"navigation/concepts/implicit-navigation/#use-case-2","title":"Use-case 2","text":""},{"location":"navigation/concepts/implicit-navigation/#requirement_1","title":"Requirement","text":"<p>Pressing the logout button on the profile screen should land us back to the login screen.</p>"},{"location":"navigation/concepts/implicit-navigation/#solution_1","title":"Solution","text":"<ol> <li><code>Root</code> either implements a <code>logout</code> callback, or subscribes to the changes of a user repository; in both cases, either the callback or the repository is passed down the tree as a dependency</li> <li><code>Profile</code> invokes the callback or a <code>logout</code> method on the repository</li> <li><code>Root</code> notices the state change, and switches its navigation to the <code>Logged out</code> scope</li> <li><code>Logged out</code> loads its initial navigation target, <code>Login</code></li> </ol> <p>Bonus</p> <p>Note how the entire <code>Logged in</code> scope is destroyed without any extra effort. The next time a login happens, all state is created anew. </p>"},{"location":"navigation/concepts/implicit-navigation/#summary","title":"Summary","text":"<p>Implicit navigation allows you to implement navigation without introducing unnecessary coupling in the tree, and successfully covers the majority of navigation scenarios.</p> <p>In case it's not enough to meet your needs, see the next chapter, Explicit navigation</p>"},{"location":"navigation/concepts/model-driven-navigation/","title":"Model-driven navigation","text":""},{"location":"navigation/concepts/model-driven-navigation/#your-own-navigation-model","title":"Your own navigation model","text":"<p>Generally speaking, most navigation solutions have fixed navigation mechanisms (e.g. a back stack).</p> <p>Appyx gives you the freedom to define your own navigation model using any Appyx component. For example, you can implement any of the examples you see here with the same approach, then use them in your navigation tree:</p> <p> </p>"},{"location":"navigation/concepts/model-driven-navigation/#no-screen-only-a-viewport","title":"No screen, only a viewport","text":"<p>Generally speaking, most navigation solutions model a \"Screen\" and focus on how to get from one screen to another.</p> <p>Appyx does not have the concept of the screen baked in \u2013 there's only a viewport, and whatever fills the available space will feel like the screen to the user.</p> <p>This freedom allows you to implement:</p> <ul> <li>Navigation that feels like going from \"screen to screen\"</li> <li>Navigation \"inside the screen\"</li> <li>Navigation that bridges between the two</li> </ul> <p>For example, you can transform the screen itself as part of navigation:</p> <p></p>"},{"location":"navigation/concepts/model-driven-navigation/#appyxcomponents","title":"AppyxComponents","text":"<p>An <code>AppyxComponent</code> implements any of the above mechanisms. </p> <p>See AppyxComponents for more details. </p>"},{"location":"navigation/concepts/model-driven-navigation/#composable-navigation","title":"Composable navigation","text":"<p><code>AppyxComponents</code> in Appyx are composable.</p> <p>See Composable navigation for more details.</p>"},{"location":"navigation/features/childaware/","title":"ChildAware API","text":"<p>The <code>ChildAware</code> interface allows you to scope communication with (or between) dynamically available child nodes easily.</p>"},{"location":"navigation/features/childaware/#baseline","title":"Baseline","text":"<p>In the next examples:</p> <ol> <li>Let's assume that <code>SomeNode</code> can host multiple child nodes: <code>Child1</code>, <code>Child2</code>, etc.</li> <li><code>SomeInteractor</code> belongs to <code>SomeNode</code> and is passed as a Plugin    to it</li> <li><code>SomeInteractor</code> extends the <code>Interactor</code> helper class from the framework:<ul> <li>It implements <code>NodeLifecycleAware</code>, which makes sure it will receive the <code>onCreate</code> callback   from the framework</li> <li>It implements <code>ChildAware</code>, which unlocks the DSL we'll see in the following   snippets</li> </ul> </li> </ol>"},{"location":"navigation/features/childaware/#single-child-scenario","title":"Single child scenario","text":"<pre><code>import com.bumble.appyx.navigation.lifecycle.Lifecycle\nimport com.bumble.appyx.core.children.whenChildAttached\nimport com.bumble.appyx.core.children.whenChildrenAttached\nimport com.bumble.appyx.core.clienthelper.interactor.Interactor\n\n\nclass SomeInteractor : Interactor&lt;SomeNode&gt;() {\n\n    override fun onCreate(lifecycle: Lifecycle) {\n        lifecycle.subscribe(onCreate = {\n\n            // This lambda is executed every time a node of type Child1Node is attached:\n            whenChildAttached { commonLifecycle: Lifecycle, child1: Child1Node -&gt;\n                // TODO:\n                //  - establish communication with child1 \n                //  - use commonLifecycle for scoping \n                //  - it will be capped by the lifecycles of child1 and the parent\n            }\n        })\n    }\n}\n</code></pre> <p>Note: Lifecycle is multiplatform.</p>"},{"location":"navigation/features/childaware/#multiple-children","title":"Multiple children","text":"<pre><code>import androidx.lifecycle.Lifecycle\nimport com.bumble.appyx.core.children.whenChildAttached\nimport com.bumble.appyx.core.children.whenChildrenAttached\nimport com.bumble.appyx.core.clienthelper.interactor.Interactor\n\n\nclass SomeInteractor : Interactor&lt;SomeNode&gt;() {\n\n    override fun onCreate(lifecycle: Lifecycle) {\n        lifecycle.subscribe(onCreate = {\n\n            // This lambda is executed every time these two nodes are attached at the same time:\n            whenChildrenAttached { commonLifecycle: Lifecycle, child1: Child1Node, child2: Child2Node -&gt;\n                // TODO\n                //  - establish communication between child1 &amp; child2 \n                //  - use commonLifecycle for scoping\n                //  - it will be capped by the lifecycles of child1, child2 and the parent\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"navigation/features/deep-linking/","title":"Deep linking","text":"<p>Building on top of explicit navigation, implementing deep links is straightforward:</p> <pre><code>class ExplicitNavigationExampleActivity : NodeActivity(), Navigator {\n\n    lateinit var rootNode: RootNode\n\n    fun handleDeepLink(intent: Intent) {\n        if (intent.action == Intent.ACTION_VIEW) {\n            when {\n                (it.data?.host == \"onboarding\") -&gt; navigateToOnBoarding()\n                else -&gt; Unit\n            }\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            NodeHost(integrationPoint = appyxIntegrationPoint) {\n                RootNode(\n                    nodeContext = it,\n                    plugins = listOf(object : NodeReadyObserver&lt;RootNode&gt; {\n                        override fun init(node: RootNode) {\n                            rootNode = node\n                            handleDeepLink(intent = intent)\n                        }\n                    })\n                )\n            }\n        }\n    }\n\n    private fun navigateToOnBoarding() {\n        // implement explicit navigation\n    }\n}\n</code></pre> <p>Check <code>ExplicitNavigationExampleActivity</code> in the samples to inspect the full code.</p>"},{"location":"navigation/features/lifecycle/","title":"Lifecycle","text":"<p>Nodes have their own lifecycles.</p> <p>The relevant class Lifecycle is multiplatform.</p>"},{"location":"navigation/features/lifecycle/#capping","title":"Capping","text":"<p>No node can be in a higher lifecycle state than any of its parents or the platform-relevant App component (e.g. Android Activity) it lives in.</p>"},{"location":"navigation/features/lifecycle/#on-screen-off-screen","title":"On-screen &amp; off-screen","text":"<p>Appyx controls which children of an <code>AppyxComponent</code> should be added to the composition and which should not, based on their state and properties. This is done automatically.</p>"},{"location":"navigation/features/lifecycle/#lifecycle-changes","title":"Lifecycle changes","text":"<p>Child elements automatically receive appropriate lifecycle callbacks. The lifecycle state can be affected by:</p> <ul> <li>The <code>AppyxComponent</code> of the parent (adding or removing child <code>Nodes</code> and changing their on-screen status)</li> <li>The parent's lifecycle state capping its children (transitive in the tree)</li> <li>On Android, Activity lifecycle will be capping the whole tree</li> </ul>"},{"location":"navigation/features/lifecycle/#back-stack-node-lifecycle","title":"Back stack node lifecycle","text":"<p>An example demonstrating the above:</p> <p></p> <p>Note that individual <code>AppyxComponents</code> might have their slight differences (e.g. whether their operations remove a <code>Node</code> only from the view, or completely destroy it).</p> <p>In the case of the back stack:</p> <ul> <li>The <code>Push</code> operation adds a new element and stashes the currently active one \u2013 the stashed one will be removed from the view &amp; <code>STOPPED</code></li> <li>The <code>Pop</code> operation removes an element, the child <code>Node</code> will be <code>DESTROYED</code></li> </ul>"},{"location":"navigation/features/material3/","title":"Material 3 support","text":"<p>Optional support for Material 3 that renders Appyx navigation using a Navigation bar or a Navigation rail.</p>"},{"location":"navigation/features/material3/#how-to-use","title":"How to use","text":""},{"location":"navigation/features/material3/#1-setup","title":"1. Setup","text":"<p>To add the proper gradle artifacts, please refer to: Downloads</p>"},{"location":"navigation/features/material3/#2-define-your-navigation-config","title":"2. Define your navigation config","text":"<pre><code>import com.bumble.appyx.utils.material3.AppyxNavItem\nimport com.bumble.appyx.utils.multiplatform.Parcelable\nimport com.bumble.appyx.utils.multiplatform.Parcelize\n\n@Parcelize\nenum class MainNavItem : Parcelable {\n    DESTINATION1, DESTINATION2, DESTINATION3;\n\n    companion object {\n        val resolver: (MainNavItem) -&gt; AppyxNavItem = { navBarItem -&gt;\n            when (navBarItem) {\n                DESTINATION1 -&gt; AppyxNavItem(\n                    text = \"Title 1\",\n                    unselectedIcon = TODO(),\n                    selectedIcon = TODO(),\n                    iconModifier = Modifier,\n                    node = { YourAppyxNode1(it) }\n                )\n\n                DESTINATION2 -&gt; AppyxNavItem(\n                    text = \"Title 2\",\n                    unselectedIcon = TODO(),\n                    selectedIcon = TODO(),\n                    iconModifier = Modifier,\n                    node = { YourAppyxNode2(it) }\n                )\n\n                DESTINATION3 -&gt; AppyxNavItem(\n                    text = \"Title 3\",\n                    unselectedIcon = TODO(),\n                    selectedIcon = TODO(),\n                    iconModifier = Modifier,\n                    node = { YourAppyxNode3(it) }\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/features/material3/#3-create-an-instance-of-appyxmaterial3navnode-and-pass-your-config-to-it","title":"3. Create an instance of <code>AppyxMaterial3NavNode</code> and pass your config to it","text":"<pre><code>AppyxMaterial3NavNode&lt;MainNavItem&gt;(\n    nodeContext = nodeContext,\n    navTargets = MainNavItem.values().toList(),\n    navTargetResolver = MainNavItem.resolver\n)\n</code></pre>"},{"location":"navigation/features/material3/#4-done","title":"4. Done!","text":"<p>Use this node as you would use any other Appyx node. <code>AppyxMaterial3NavNode</code> renders either a Navigation bar or a Navigation rail depending on the screen size:</p> <p> </p> <p>You can check the live multiplatform demo in the :demos:appyx-navigation module.</p>"},{"location":"navigation/features/material3/#customisation-options","title":"Customisation options","text":"<p>You can set a different animation spec applied to the default crossfade:</p> <pre><code>AppyxMaterial3NavNode&lt;MainNavItem&gt;(\n    animationSpec = spring(Spring.StiffnessMedium)\n)\n</code></pre> <p>Or you can set a different visualisation altogether:</p> <pre><code>AppyxMaterial3NavNode&lt;MainNavItem&gt;(\n    /*...*/\n    visualisation = { SpotlightSlider(it) }\n)\n</code></pre> <p>For a list of possible visualisations you can refer to Spotlight documentation.</p> <p>You can also extend the class and override when to display a Navigation bar or a rail. These are the defaults:</p> <pre><code>@Composable\nopen fun shouldUseNavigationBar(): Boolean =\n    LocalScreenSize.current.windowSizeClass == COMPACT\n\n@Composable\nopen fun shouldUseNavigationRail(): Boolean =\n    !shouldUseNavigationBar()\n</code></pre>"},{"location":"navigation/features/plugins/","title":"Plugins","text":""},{"location":"navigation/features/plugins/#keeping-extra-concerns-out-of-node","title":"Keeping extra concerns out of Node","text":"<p><code>Nodes</code> are meant to be simple structural elements, and should be kept lean.</p> <p>To keep the framework agnostic of any specific approach / pattern you want to use, there aren't any fixed parts. Rather, the <code>Node</code> offers an extension point using <code>Plugins</code> in its constructor:</p> <pre><code>abstract class Node(\n    nodeContext: NodeContext,\n    val view: NodeView = EmptyNodeView,\n    plugins: List&lt;Plugin&gt; = emptyList() // &lt;--\n)\n</code></pre> <p>So what is a <code>Plugin</code>?</p> <p>A <code>Plugin</code> is an empty interface extended by many actual ones:</p> <pre><code>interface Plugin\n</code></pre>"},{"location":"navigation/features/plugins/#plugins_1","title":"Plugins","text":""},{"location":"navigation/features/plugins/#lifecycle-related-plugins","title":"Lifecycle-related plugins","text":"<pre><code>interface NodeLifecycleAware : Plugin {\n    fun onCreate(lifecycle: Lifecycle) {}\n}\n\nfun interface Destroyable : Plugin {\n    fun destroy()\n}\n</code></pre>"},{"location":"navigation/features/plugins/#component-level-plugins","title":"Component level plugins","text":"<p>Sometimes you need to grab a reference to the component as a whole, either as an interface, or its implementation, the <code>Node</code>.</p> <p>This will come especially handy when working with workflows.</p> <pre><code>interface NodeAware : Plugin {\n    val node: Node&lt;*&gt;\n\n    fun init(node: Node&lt;*&gt;) {}\n}\n</code></pre> <p>There are helper classes found in the library, so you don't have to implement the above interfaces, you can just use delegation:</p> <pre><code>class SomeClass(\n    private val nodeAware: NodeAware = NodeAwareImpl()\n) : NodeAware by nodeAware {\n\n    fun foo() {\n        // [node] is an automatically available property coming from the NodeAware interface\n        // the reference is automatically set for you by the framework + the NodeAwareImpl class\n        // so you can use it right away:\n        node.doSomething()\n    }\n}\n</code></pre> <p>\u26a0\ufe0f Note: the reference to <code>node</code> is set by <code>Node</code> automatically, and isn't available immediately after constructing your object, but only after the construction of the <code>Node</code> itself.</p>"},{"location":"navigation/features/plugins/#navigation-plugins","title":"Navigation plugins","text":"<p>In case if you need to control navigation behaviour, you can use these plugins:</p> <pre><code>interface UpNavigationHandler : Plugin {\n    fun handleUpNavigation(): Boolean = false\n}\n\ninterface BackPressHandler : Plugin {\n    val onBackPressedCallback: OnBackPressedCallback? get() = null\n}\n</code></pre> <p><code>UpNavigationHandler</code> controls <code>Node.navigateUp</code> behaviour and allows to intercept its invocation.</p> <p><code>BackPressHandler</code> controls device back press behaviour via <code>androidx.activity.OnBackPressedCallback</code>. You can read more about it here.</p> <p>\u26a0\ufe0f Note: <code>OnBackPressedCallback</code> are invoked in the following order: 1. From children to parents. Render order of children matters! The last rendered child will be the first to handle back press. 2. Direct order of plugins within a node. Plugins are invoked in order they appears in <code>Node(plugins = ...)</code> before the AppyxComponent. </p>"},{"location":"navigation/features/plugins/#using-plugins","title":"Using Plugins","text":"<p>All plugins are designed to have empty <code>{}</code> default implementations (or other sensible defaults when a return value is defined), so it's convenient to implement them only if you need.</p> <p>Don't forget to pass your <code>Plugins</code> to your <code>Node</code>:</p> <pre><code>internal class MyNode(\n    // ...\n    plugins: List&lt;Plugins&gt; = emptyList()\n    // ...\n) : Node&lt;Nothing&gt;(\n    // ...\n    plugins = plugins\n    // ...\n)\n</code></pre> <p>\u26a0\ufe0f Note: <code>plugins</code> is a <code>List</code>, as the order matters here. All <code>Plugin</code> instances are invoked in the order they appear in the list.</p>"},{"location":"navigation/features/scoped-di/","title":"Scoped DI","text":"<p>Once you represent your navigation in a Composable way, you will get powerful DI scoping as a pleasant side-effect:</p> <p></p> <p>Appyx gives every single <code>Node</code> its own DI scope for free, with no extra effort required to clean up these scopes other than navigating away from them.</p>"},{"location":"navigation/features/scoped-di/#how-does-this-work","title":"How does this work?","text":"<ol> <li>Imagine you create an object in the <code>Node</code> related to <code>Onboarding</code>, and make it available to all of its children.</li> <li>While navigation is advancing between the individual screens of Onboarding, <code>O1</code> \u2013 <code>O2</code> \u2013 <code>O3</code>, this object will be the same instance.</li> <li>As soon as the navigation switches to <code>Main</code>, the entire subtree of <code>Onboarding</code> is destroyed and all held objects are released.</li> <li>Should the navigation ever go back to <code>Onboarding</code>, said object would be created from scratch.</li> </ol> <p>This of course applies to every other <code>Node</code> in the tree.</p>"},{"location":"navigation/features/scoped-di/#scoping-in-practice","title":"Scoping in practice","text":"<p>Imagine in a larger tree:</p> <p></p> <ol> <li>A logout action is represented as switching the navigation back to the <code>Logged out</code> node</li> <li>This will destroy the entire <code>Logged in</code> scope automatically </li> <li>All objects held in the scope of an authenticated state are released without any special effort.</li> </ol> <p>You could also use this for DI scoping flows (e.g. a cart object during a multi-screen product checkout). </p> <p>With a regular approach these cases could be more difficult to represent:</p> <ul> <li>Screen-bound scopes wouldn't allow multi-screen lifetime of the objects.</li> <li>Application-scoped singletons would require extra attention of cleaning up once the flow ends.</li> </ul> <p>With Appyx you get best of both worlds for free.</p>"},{"location":"navigation/features/surviving-configuration-changes/","title":"Surviving configuration changes","text":"<p>To retain objects during configuration change you can use the <code>RetainedInstanceStore</code> class.</p>"},{"location":"navigation/features/surviving-configuration-changes/#how-does-it-work","title":"How does it work?","text":"<p>The <code>RetainedInstanceStore</code> stores objects within a singleton.</p> <p>Every <code>Node</code> has access to the <code>RetainedInstanceStore</code> and manages these cases automatically:</p> <ul> <li>The <code>Activity</code> is recreated: the retained instance is returned instead of a new instance.</li> <li>The <code>Activity</code> is destroyed: the retained instance is removed and disposed.</li> </ul>"},{"location":"navigation/features/surviving-configuration-changes/#example","title":"Example","text":"<p>Appyx provides extension methods on the <code>NodeContext</code> class (an instance which is passed to every <code>Node</code> upon creation) to access the <code>RetainedInstanceStore</code>. You can use these to:</p> <ul> <li>Create your retained objects (<code>factory</code>)</li> <li>Define cleanup mechanisms (<code>disposer</code>) to be run when the retained object will be removed on <code>Activity</code> destroy.</li> </ul> <p>You can opt to use the <code>Builder</code> pattern to provide dependencies to your <code>Node</code> and separate this logic:</p> <p>Note: to use the rx2/rx3 <code>getRetainedDisposable</code> extension methods you see below, you need to add the relevant gradle dependencies. Please refer to Downloads.</p> <pre><code>import com.bumble.appyx.navigation.builder.Builder\nimport com.bumble.appyx.navigation.modality.NodeContext\nimport com.bumble.appyx.navigation.node.Node\nimport com.bumble.appyx.navigation.store.getRetainedInstance\nimport com.bumble.appyx.utils.interop.rx2.store.getRetainedDisposable\n\nclass YourNodeBuilder : Builder&lt;YourPayload&gt;() {\n\n    override fun build(nodeContext: NodeContext, payload: YourPayload): Node {\n        // Case 1:\n        // If your type implements an rx2/rx3 Disposable,\n        // you don't need to pass a disposer:\n        val retainedFoo = nodeContext.getRetainedDisposable {\n            Foo(payload)\n        }\n\n        // Case 2:\n        // If your type doesn't implement an rx2/rx3 Disposable,\n        // you can define a custom cleanup mechanism:\n        val retainedFoo = nodeContext.getRetainedInstance(\n            factory = { Foo(payload) },\n            disposer = { it.cleanup() } // it: Foo\n        )\n\n        val view = YourNodeViewImpl()\n\n        return YourNode(\n            nodeContext = nodeContext,\n            foo = retainedFoo, \n            view = view,\n        )\n    }\n}\n</code></pre>"},{"location":"navigation/integrations/compose-navigation/","title":"Appyx + Jetpack Compose Navigation","text":"<p>You can easily make Appyx co-exist with Jetpack Compose Navigation. This might be useful if:</p> <ul> <li>You want to to use some AppyxComponents for navigation in your non-Appyx app.</li> <li>You want to migrate to Appyx gradually.</li> </ul> <p>No special downloads are required.</p>"},{"location":"navigation/integrations/compose-navigation/#sample","title":"Sample","text":"<pre><code>/**\n * This Composable demonstrates how to add Appyx into Jetpack Compose Navigation.\n */\n@Composable\nfun ComposeNavigationRoot(modifier: Modifier = Modifier) {\n    val googleNavController = rememberNavController()\n    NavHost(\n        navController = googleNavController,\n        startDestination = \"google-route\"\n    ) {\n        composable(\"google-route\") {\n            GoogleRoute { googleNavController.navigate(\"appyx-route\") }\n        }\n        composable(\"appyx-route\") {\n            AppyxRoute { googleNavController.navigate(\"google-route\") }\n        }\n    }\n}\n\n@Composable\ninternal fun GoogleRoute(\n    modifier: Modifier = Modifier,\n    onNavigateToAppyxRoute: () -&gt; Unit\n) {\n    Column(\n        modifier = modifier.fillMaxWidth(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Compose Navigation screen\")\n        Button(onClick = { onNavigateToAppyxRoute() }) {\n            Text(\"Navigate to Appyx\")\n        }\n    }\n}\n\n\n@Composable\ninternal fun AppyxRoute(\n    onNavigateToGoogleRoute: () -&gt; Unit\n) {\n    NodeHost(integrationPoint = LocalIntegrationPoint.current) {\n        RootNode(\n            nodeContext = it,\n            // use this in the Node / some child Node,\n            // in business logic or in the view on some button:\n            onNavigateToGoogleRoute = onNavigateToGoogleRoute \n        )\n    }\n}\n</code></pre>"},{"location":"navigation/integrations/di-frameworks/","title":"Appyx + DI frameworks","text":""},{"location":"navigation/integrations/di-frameworks/#appyx-hilt","title":"Appyx + Hilt","text":"<p>We've experimented with adding Hilt support for Appyx Nodes, however the solution is not yet finalised.</p> <p>You can track and vote on the issue here:</p> <ul> <li>#552 - Integration: Appyx + Hilt</li> </ul>"},{"location":"navigation/integrations/di-frameworks/#appyx-kodein","title":"Appyx + Kodein","text":"<p>If you'd like us to prioritise it, you can vote on the issue here:</p> <ul> <li>#555 - Integration: Appyx + Kodein</li> </ul>"},{"location":"navigation/integrations/di-frameworks/#appyx-koin","title":"Appyx + Koin","text":"<p>If you'd like us to prioritise it, you can vote on the issue here:</p> <ul> <li>#554 - Integration: Appyx + Koin</li> </ul>"},{"location":"navigation/integrations/di-frameworks/#appyx-dagger","title":"Appyx + Dagger","text":"<p>If you're not too bothered to create the extra classes for Dagger yourself, you can make it work pretty nicely with a tree-based approach like Appyx. We have detailed this in this project's predecessor, badoo/RIBs \u2013 however we moved away from it and didn't implement a sample in the scope Appyx. </p>"},{"location":"navigation/integrations/di-frameworks/#appyx-manual-di","title":"Appyx + Manual DI","text":"<p>It's worth mentioning that while manual DI in an unstructured project sounds like a bad idea, with a tree-scoped project structure it can be viable. </p> <p>Benefits:</p> <ul> <li>Scoped DI for free.</li> <li>The tree provides a good enough structure to make it understandable.</li> <li>Less boilerplate than with Dagger.</li> </ul>"},{"location":"navigation/integrations/ribs/","title":"Appyx + RIBs","text":"<p>Interop classes for a gradual migration from badoo/RIBs to Appyx. Please refer to Downloads for gradle artifacts.</p>"},{"location":"navigation/integrations/ribs/#provided-classes","title":"Provided classes","text":"<ul> <li><code>InteropActivity</code></li> <li><code>InteropBackPressHandler</code></li> <li><code>InteropBuilder</code></li> <li><code>InteropNode</code></li> <li><code>InteropView</code></li> </ul>"},{"location":"navigation/integrations/rx/","title":"Appyx + RxJava","text":"<p>Rx2 and Rx3 implementations are provided for the functionality below. Please refer to Downloads for gradle artifacts.</p>"},{"location":"navigation/integrations/rx/#connectable","title":"Connectable","text":"<p>You can use this together with the ChildAware API to set up communication between Nodes in a decoupled way:</p> <pre><code>interface Connectable&lt;Input, Output&gt; : NodeLifecycleAware {\n    val input: Relay&lt;Input&gt;\n    val output: Relay&lt;Output&gt;\n}\n</code></pre>"},{"location":"navigation/integrations/rx/#retainedinstancestore","title":"RetainedInstanceStore","text":"<p>Provides a singleton store to survive configuration changes. The rx2/rx3 helpers add automatic disposal on objects implementing <code>Disposable</code>.</p> <p>You can find more details here: Surviving configuration change </p> <pre><code>import com.bumble.appyx.utils.interop.rx2.store.getRetainedDisposable\n\nclass YourNodeBuilder : Builder&lt;YourPayload&gt;() {\n\n    override fun build(nodeContext: NodeContext, payload: YourPayload): Node {\n\n        // If your type implements an rx2/rx3 Disposable,\n        // you don't need to pass a disposer:\n        val retainedFoo = nodeContext.getRetainedDisposable {\n            Foo(payload)\n        }\n\n        return YourNode(\n            nodeContext = nodeContext,\n            foo = retainedFoo, \n            view = view,\n        )\n    }\n}\n</code></pre>"},{"location":"navigation/integrations/viewmodel/","title":"Appyx + ViewModel","text":"<p>We've experimented with adding ViewModel support for Appyx Nodes, however the solution is not finalised.</p> <p>You can track and vote on the issue here: </p> <ul> <li>#553 - Integration: Appyx + ViewModel</li> </ul>"},{"location":"navigation/integrations/viewmodel/#alternative-retainedinstancestore","title":"Alternative: <code>RetainedInstanceStore</code>","text":"<p>Even without a direct ViewModel support, you can pretty much achieve the same by using the RetainedInstanceStore Appyx provides.</p>"},{"location":"releases/2.0.0-alpha10/","title":"2.0.0-alpha10 \u2013 Migration guide","text":""},{"location":"releases/2.0.0-alpha10/#artifact-id-changes","title":"Artifact id changes","text":"<pre><code>// Material3 helpers\n-implementation(\"com.bumble.appyx:material3-android:$version\")\n+implementation(\"com.bumble.appyx:utils-material3-android:$version\")\n\n// KSP (only used for custom Visualisations)\n-ksp(\"com.bumble.appyx:mutable-ui-processor:{latest version}\")\n+ksp(\"com.bumble.appyx:appyx-processor:{latest version}\")\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#package-changes","title":"Package changes","text":"<pre><code>// Moved all classes:\n-com.bumble.appyx.navigation.integrationpoint.*\n+com.bumble.appyx.navigation.integration.*\n\n// Moved class:\n-com.bumble.appyx.navigation.navigation.UpNavigationHandler\n+com.bumble.appyx.navigation.integration.UpNavigationHandler\n\n// Removed duplicate typealias and moved to utils:\n-import com.bumble.appyx.interactions.core.state.SavedStateMap\n-import com.bumble.appyx.navigation.state.SavedStateMap\n+import com.bumble.appyx.utils.multiplatform.SavedStateMap\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#rename-node-parentnode","title":"Rename <code>Node</code> &amp; <code>ParentNode</code>","text":"<pre><code>class YourNode(\n    /*...*/\n-) : Node(\n+) : LeafNode(\n    /*...*/\n) {\n}\n</code></pre> <pre><code>class YourNode(\n    /*...*/\n-) : ParentNode&lt;T&gt;(\n+) : Node&lt;T&gt;(\n    /*...*/\n) {\n}\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#rename-view-composable","title":"Rename <code>View</code> composable","text":"<pre><code>class YourNode(\n    /*...*/\n) : Node&lt;T&gt; {\n\n    @Composable\n-    override fun View(modifier: Modifier) {\n+    override fun Content(modifier: Modifier) {\n    }\n}\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#rename-ambiguous-appyxcomponent-composables","title":"Rename ambiguous <code>AppyxComponent</code> composables","text":"<p>When used in the scope of Appyx Navigation: </p> <pre><code>-import com.bumble.appyx.navigation.composable.AppyxComponent\n+import com.bumble.appyx.navigation.composable.AppyxNavigationContainer\n\nclass YourNode(\n    /*...*/\n) : Node&lt;T&gt; {\n\n    @Composable\n    override fun Content(modifier: Modifier) {\n-        AppyxComponent(\n+        AppyxNavigationContainer(\n            appyxComponent = yourComponent,\n            modifier = modifier\n        )   \n    }\n}\n</code></pre> <p>When used in the scope of Appyx Interactions: </p> <pre><code>-import com.bumble.appyx.interactions.core.AppyxComponent\n+import com.bumble.appyx.interactions.core.AppyxInteractionsContainer\n\n@Composable\nfun SomeComposable() {\n-    AppyxComponent(\n+    AppyxInteractionsContainer(\n        appyxComponent = yourComponent,\n        screenWidthPx = TODO(),\n        screenHeightPx = TODO(),\n        clipToBounds = false,\n        modifier = Modifier,\n        element = { elementUiModel -&gt;\n            YourElementComposable(\n                elementUiModel = elementUiModel,\n                modifier = elementUiModel.modifier\n            )\n        }\n    )\n}\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#rename-buildcontext-buildcontext","title":"Rename <code>BuildContext</code> &amp; <code>buildContext</code>","text":"<pre><code>-import com.bumble.appyx.navigation.modality.BuildContext\n+import com.bumble.appyx.navigation.modality.NodeContext\n\nclass YourNode(\n-    buildContext: BuildContext,\n+    nodeContext: NodeContext,\n    /*...*/\n) : Node&lt;NavTarget&gt; {\n-    buildContext = buildContext\n+    nodeContext = nodeContext\n    /*...*/\n) {\n}\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#rename-resolve","title":"Rename <code>resolve</code>","text":"<pre><code>class YourNode(\n    /*...*/\n) : Node&lt;NavTarget&gt; {\n    /*...*/\n) {\n    sealed class NavTarget : Parcelable {\n        /*...*/\n    }\n\n-    override fun resolve(navTarget: NavTarget, buildContext: BuildContext): Node =\n+    override fun buildChildNode(navTarget: NavTarget, nodeContext: NodeContext): Node =\n        when (navTarget) {\n            TODO()\n        }\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#changes-unlikely-to-affect-you-directly","title":"Changes unlikely to affect you directly","text":""},{"location":"releases/2.0.0-alpha10/#changes-to-nodeview","title":"Changes to <code>NodeView</code>","text":"<p>You only need to care about these changes if you separated out your view to a class implementing the <code>NodeView</code> interface.</p> <p>If you implemented your <code>@Composable override fun Content(modifier: Modifier)</code> directly in your <code>Node</code>, you don't need to do anything.</p> <ol> <li> <p>We've dropped generics from <code>NodeView</code> interface</p> <pre><code>-interface NodeView&lt;NavTarget : Any&gt;\n+interface NodeView\n</code></pre> <p>If you had an implementation of this interface, drop the generic from your class too.</p> </li> <li> <p>We've unified <code>NodeView</code> and <code>ParentNodeView</code></p> <p>If you used <code>ParentNodeView</code>, just replace the usage with <code>NodeView</code>.</p> </li> <li> <p>We've unified <code>EmptyNodeView</code> and <code>EmptyParentNodeView</code></p> <p>If you used <code>EmptyParentNodeView</code>, just replace the usage with <code>EmptyNodeView</code>.</p> </li> </ol>"},{"location":"releases/2.0.0-alpha10/#swap-the-order-of-targetuistate-mutableuistate","title":"Swap the order of <code>TargetUiState</code>, <code>MutableUiState</code>","text":"<p>You only need to do this if you implemented your own <code>Visualisation</code>. If you only relied on the ones supplied by the library, you don't need to do anything.</p> <pre><code>class SomeVisualisation(\n    /*...*/\n-) : BaseVisualisation&lt;T, State&lt;T&gt;, MutableUiState, TargetUiState&gt;(\n+) : BaseVisualisation&lt;T, State&lt;T&gt;, TargetUiState, MutableUiState&gt;(\n</code></pre>"},{"location":"releases/2.0.0-alpha10/#ksp-generated-method-name-change","title":"KSP generated method name change","text":"<p>You only need to do this if you implemented your own <code>Visualisation</code>. If you only relied on the ones supplied by the library, you don't need to do anything.</p> <pre><code>override fun mutableUiStateFor(\n    uiContext: UiContext,\n    targetUiState: TargetUiState\n): MutableUiState =\n-    targetUiState.toMutableState(uiContext)\n+    targetUiState.toMutableUiState(uiContext)\n</code></pre>"},{"location":"releases/2.0.0-alpha11/","title":"2.0.0-alpha11 \u2013 Migration guide","text":""},{"location":"releases/2.0.0-alpha11/#package-changes","title":"Package changes","text":"<pre><code>// Moved all classes:\n-com.bumble.appyx.interactions.core.gesture.*\n-com.bumble.appyx.interactions.ui.gesture.*\n+com.bumble.appyx.interactions.gesture.*\n\n// Moved specific classes:\n-com.bumble.appyx.interactions.AppyxInteractionContainer\n+com.bumble.appyx.interactions.composable.AppyxInteractionContainer\n\n-com.bumble.appyx.interactions.GestureReferencePoint\n+com.bumble.appyx.interactions.gesture.GestureReferencePoint\n\n-com.bumble.appyx.interactions.Element\n-com.bumble.appyx.interactions.Elements\n+com.bumble.appyx.interactions.model.Element\n+com.bumble.appyx.interactions.model.Elements\n\n\n// Moved all remaining packages in core to interactions root:\n-com.bumble.appyx.interactions.core.*\n+com.bumble.appyx.interactions.*\n</code></pre>"},{"location":"releases/2.0.0-alpha11/#fixed-canhandebackpress-typo","title":"Fixed <code>canHandeBackPress</code> typo","text":"<pre><code>interface AppyxComponent /*...*/ {\n    /*...*/\n-    fun canHandeBackPress(): StateFlow&lt;Boolean&gt;\n+    fun canHandleBackPress(): StateFlow&lt;Boolean&gt;\n</code></pre>"},{"location":"releases/2.0.0-alpha11/#moved-builder-simplebuilder-and-interactor","title":"Moved <code>Builder</code>, <code>SimpleBuilder</code>, and <code>Interactor</code>","text":"<p>If you were depending on these classes being part of appyx-navigation, you\u2019ll now need to get them from \"com.bumble.appyx:utils-ribs-helpers:$version\".</p> <pre><code>+    implementation(\"com.bumble.appyx:utils-ribs-helpers:$version\")\n\n-    import com.bumble.appyx.navigation.builder.Builder\n+    import com.bumble.appyx.utils.ribshelpers.builder.Builder\n\n-    import com.bumble.appyx.navigation.builder.SimpleBuilder\n+    import com.bumble.appyx.utils.ribshelpers.builder.SimpleBuilder\n\n-    import com.bumble.appyx.navigation.clienthelper.interactor.Interactor\n+    import com.bumble.appyx.utils.ribshelpers.interactor.Interactor\n</code></pre>"},{"location":"releases/changelog/","title":"Changelog","text":""},{"location":"releases/changelog/#pending-changes","title":"Pending changes","text":""},{"location":"releases/changelog/#api-breaking-changes","title":"API breaking changes","text":"<ul> <li>#677 \u2013 Moved Builder, SimpleBuilder, Interactor to separate module</li> <li>#680 \u2013 Appyx interactions package reorg</li> </ul>"},{"location":"releases/changelog/#fixed","title":"Fixed","text":"<ul> <li>#670 - Fixes ios lifecycle</li> <li>#673 \u2013 Fix canHandeBackPress typo</li> <li>#671 \u2013 Fix ui state saving issue</li> </ul>"},{"location":"releases/changelog/#enhancement","title":"Enhancement","text":"<ul> <li>#679 \u2013 Simple api for backStackNode and spotlightNode</li> </ul>"},{"location":"releases/changelog/#200-alpha10","title":"2.0.0-alpha10","text":"<p>Please refer to 2.0.0-alpha10 \u2013 Migration guide</p>"},{"location":"releases/changelog/#api-breaking-changes_1","title":"API breaking changes","text":"<ul> <li>#630 \u2013 Pass initial state into Spotlights visualisations</li> <li>#642 \u2013 Renamings</li> <li>#643 \u2013 Unify AppyxComponent composable between appyx-navigation and appyx-interactions modules</li> <li>#651 - Keep only one instance of SaveStateMap typealias and moved it to <code>com.bumble.appyx.utils.multiplatform</code> package </li> <li>#652 - KSP processor renamed from <code>mutable-ui-processor</code> to <code>appyx-processor</code></li> <li>#654 - Renamings </li> <li>#657 - Rename ParentNode &amp; Node to Node and LeafNode </li> <li>#644 \u2013 Refactor AppyxComponent and application of draggable modifier </li> </ul>"},{"location":"releases/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>#638 - Fix visibility issue for bottom element in BackStackParallax</li> </ul> 24 Jan 2024"},{"location":"releases/changelog/#200-alpha09","title":"2.0.0-alpha09","text":""},{"location":"releases/changelog/#api-breaking-changes_2","title":"API breaking changes","text":"<ul> <li>#618 \u2013 Do not create <code>PermanentAppyxComponent</code> inside <code>ParentNode</code>. Provide it via constructor to ParentNode</li> <li>#612 \u2013 Rename <code>MotionController</code> to <code>Visualisation</code></li> <li>#617 \u2013 Unify inside &amp; outside position alignment</li> </ul>"},{"location":"releases/changelog/#changed","title":"Changed","text":"<ul> <li>#611 \u2013 Lower position and rotation animation default round-off thresholds</li> <li>#620 \u2013 Updated Compose to 1.5.3 &amp; Kotlin to 1.9.10</li> </ul>"},{"location":"releases/changelog/#added","title":"Added","text":"<ul> <li>#615 \u2013 Material navigation helpers</li> </ul> 19 Oct 2023"},{"location":"releases/changelog/#200-alpha08","title":"2.0.0-alpha08","text":""},{"location":"releases/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>#608 \u2013 Setting default value to <code>NodeCustomisationDirectory</code> in <code>IosNodeHost</code></li> </ul> 4 Oct 2023"},{"location":"releases/changelog/#200-alpha07","title":"2.0.0-alpha07","text":""},{"location":"releases/changelog/#added_1","title":"Added","text":"<ul> <li>#601 \u2013 iOS support and target apps</li> <li>#599 Added isContinuous flag to <code>GestureFactory</code></li> </ul> 4 Oct 2023"},{"location":"releases/changelog/#200-alpha06","title":"2.0.0-alpha06","text":""},{"location":"releases/changelog/#changed_1","title":"Changed","text":"<ul> <li>#594 Reverted JVM bytecode target to JDK11 instead of 17</li> </ul> 15 Sep 2023"},{"location":"releases/changelog/#200-alpha05","title":"2.0.0-alpha05","text":""},{"location":"releases/changelog/#added_2","title":"Added","text":"<ul> <li>#579 \u2013 Expose <code>AndroidLifecycle</code> in <code>PlatformLifecycleRegistry</code> for Android</li> </ul>"},{"location":"releases/changelog/#fixed_3","title":"Fixed","text":"<ul> <li>#584 \u2013 Fix applying offset twice in <code>AppyxComponent</code></li> <li>#585 \u2013 Fix drag vs align</li> <li>#571 \u2013 Avoid <code>MotionController</code> recreation</li> <li>#587 \u2013 Fix <code>DraggableChildren</code> and rename it to <code>AppyxComponent</code></li> <li>#588 \u2013 Set bounds on all new motion controllers</li> <li>#589 \u2013 Fix visibility resolution for elements that do not match parent's size</li> <li>#591 \u2013 Flush output cache when <code>onCreate</code> is called in <code>NodeConnector</code></li> <li>#592 \u2013 Fix <code>Backstack3D</code> <code>MotionController</code></li> </ul> 13 Sep 2023"},{"location":"releases/changelog/#200-alpha04","title":"2.0.0-alpha04","text":""},{"location":"releases/changelog/#fixed_4","title":"Fixed","text":"<ul> <li>#575 - Make customisations lazy to improve performance</li> </ul> 31 Aug 2023"},{"location":"releases/changelog/#200-alpha03","title":"2.0.0-alpha03","text":""},{"location":"releases/changelog/#api-breaking-changes_3","title":"API breaking changes","text":"<ul> <li>#562 \u2013 Implement custom alignment to remove screen size knowledge when offsetting element in <code>MotionController</code></li> <li>#562 \u2013 Remove <code>UiContext</code> parameter from <code>MotionProperty</code> and provide <code>BoxScope</code> via composition local</li> </ul>"},{"location":"releases/changelog/#added_3","title":"Added","text":"<ul> <li>#551 - Support Multiplatform in :appyx-navigation</li> <li>#565 - Adds <code>AngularPosition</code> via restoring <code>Promoter</code> example</li> </ul>"},{"location":"releases/changelog/#fixed_5","title":"Fixed","text":"<ul> <li>#560 \u2013 Don't remove destroyed elements on update automatically</li> </ul> 17 Aug 2023"},{"location":"releases/changelog/#200-alpha02","title":"2.0.0-alpha02","text":""},{"location":"releases/changelog/#added_4","title":"Added","text":"<ul> <li>#539 \u2013 Position alignment</li> <li>#538 \u2013 Availability to observe <code>MotionProperties</code> from children UI</li> </ul>"},{"location":"releases/changelog/#fixed_6","title":"Fixed","text":"<ul> <li>#530 \u2013 Backstack Parallax motion controller bug</li> </ul> 9 Aug 2023"},{"location":"releases/changelog/#200-alpha01","title":"2.0.0-alpha01","text":"<ul> <li>Initial release</li> </ul> 6 Jul 2023"},{"location":"releases/downloads/","title":"Downloads","text":""},{"location":"releases/downloads/#latest-version","title":"Latest version","text":""},{"location":"releases/downloads/#repository","title":"Repository","text":"<pre><code>repositories {\n    mavenCentral()\n}\n</code></pre>"},{"location":"releases/downloads/#appyx-navigation","title":"Appyx Navigation","text":"<p>Adding the gradle dependency in a non-multiplatform project:</p> <pre><code>dependencies {\n    // Platform-specific (pick the right one for your platform)\n    implementation(\"com.bumble.appyx:appyx-navigation-android:$version\")\n    implementation(\"com.bumble.appyx:appyx-navigation-desktop:$version\")\n    implementation(\"com.bumble.appyx:appyx-navigation-js:$version\")\n\n    // For iOS, you need separate dependencies for Simulator, x86 &amp; Arm\n    implementation(\"com.bumble.appyx:appyx-navigation-iossimulatorarm64:$version\")\n    implementation(\"com.bumble.appyx:appyx-navigation-iosx64:$version\")\n    implementation(\"com.bumble.appyx:appyx-navigation-iosarm64:$version\")\n}\n</code></pre> <p>Adding the gradle dependency in a multiplatform project:</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(\"com.bumble.appyx:appyx-navigation:$version\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"releases/downloads/#appyx-interactions","title":"Appyx Interactions","text":"<p>Adding the gradle dependency in a non-multiplatform project:</p> <pre><code>dependencies {\n    // Platform-specific (pick the right one for your platform)\n    implementation(\"com.bumble.appyx:appyx-interactions-android:$version\")\n    implementation(\"com.bumble.appyx:appyx-interactions-desktop:$version\")\n    implementation(\"com.bumble.appyx:appyx-interactions-js:$version\")\n\n    // For iOS, you need separate dependencies for Simulator, x86 &amp; Arm\n    implementation(\"com.bumble.appyx:appyx-interactions-iossimulatorarm64:$version\")\n    implementation(\"com.bumble.appyx:appyx-interactions-iosx64:$version\")\n    implementation(\"com.bumble.appyx:appyx-interactions-iosarm64:$version\")\n}\n</code></pre> <p>Adding the gradle dependency in a multiplatform project:</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(\"com.bumble.appyx:appyx-interactions:$version\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"releases/downloads/#appyx-components","title":"Appyx Components","text":""},{"location":"releases/downloads/#back-stack","title":"Back stack","text":"<p>Adding the gradle dependency in a non-multiplatform project:</p> <pre><code>dependencies {\n    // Platform-specific (pick the right one for your platform)\n    implementation(\"com.bumble.appyx:backstack-android:$version\")\n    implementation(\"com.bumble.appyx:backstack-desktop:$version\")\n    implementation(\"com.bumble.appyx:backstack-js:$version\")\n\n    // For iOS, you need separate dependencies for Simulator, x86 &amp; Arm\n    implementation(\"com.bumble.appyx:backstack-iossimulatorarm64:$version\")\n    implementation(\"com.bumble.appyx:backstack-iosx64:$version\")\n    implementation(\"com.bumble.appyx:backstack-iosarm64:$version\")\n}\n</code></pre> <p>Adding the gradle dependency in a multiplatform project:</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // Use api, not implementation!\n                api(\"com.bumble.appyx:backstack:$version\")\n            }\n        }\n\n    }\n}\n</code></pre>"},{"location":"releases/downloads/#spotlight","title":"Spotlight","text":"<p>Adding the gradle dependency in a non-multiplatform project:</p> <pre><code>dependencies {\n    // Platform-specific (pick the right one for your platform)\n    implementation(\"com.bumble.appyx:spotlight-android:$version\")\n    implementation(\"com.bumble.appyx:spotlight-desktop:$version\")\n    implementation(\"com.bumble.appyx:spotlight-js:$version\")\n\n    // For iOS, you need separate dependencies for Simulator, x86 &amp; Arm\n    implementation(\"com.bumble.appyx:spotlight-iossimulatorarm64:$version\")\n    implementation(\"com.bumble.appyx:spotlight-iosx64:$version\")\n    implementation(\"com.bumble.appyx:spotlight-iosarm64:$version\")\n}\n</code></pre> <p>Adding the gradle dependency in a multiplatform project:</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // Use api, not implementation!\n                api(\"com.bumble.appyx:spotlight:$version\")\n            }\n        }\n\n    }\n}\n</code></pre>"},{"location":"releases/downloads/#utils-and-interop-with-other-libraries","title":"Utils and interop with other libraries","text":""},{"location":"releases/downloads/#material-3-support","title":"Material 3 support","text":"<p>Support for Navigation bar, Navigation rail to use easily together with Appyx Navigation.</p> <p>See more in Material 3 support.</p> <p>Adding the gradle dependency in a non-multiplatform project:</p> <pre><code>dependencies {\n    // Platform-specific (pick the right one for your platform)\n    implementation(\"com.bumble.appyx:utils-material3-android:$version\")\n    implementation(\"com.bumble.appyx:utils-material3-desktop:$version\")\n    implementation(\"com.bumble.appyx:utils-material3-js:$version\")\n    implementation(\"com.bumble.appyx:utils-material3-iosarm64:$version\")\n    implementation(\"com.bumble.appyx:utils-material3-iossimulatorarm64:$version\")\n    implementation(\"com.bumble.appyx:utils-material3-iosx64:$version\")\n}\n</code></pre> <p>Adding the gradle dependency in a multiplatform project:</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // Use api, not implementation!\n                api(\"com.bumble.appyx:utils-material3:$version\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"releases/downloads/#rxjava-2","title":"RxJava 2","text":"<pre><code>dependencies {\n    // Optional support for RxJava 2/3\n    implementation(\"com.bumble.appyx:utils-interop-rx2:$version\")\n}\n</code></pre>"},{"location":"releases/downloads/#rxjava-3","title":"RxJava 3","text":"<pre><code>dependencies {\n    implementation(\"com.bumble.appyx:utils-interop-rx3:$version\")\n}\n</code></pre>"},{"location":"releases/downloads/#badooribs","title":"badoo/RIBs","text":"<pre><code>repositories {\n    // Don't forget to add this, since badoo/RIBs is hosted on jitpack:\n    maven(url = \"https://jitpack.io\")\n}\n\ndependencies {\n    implementation(\"com.bumble.appyx:utils-interop-ribs:$version\")\n}\n</code></pre>"},{"location":"releases/downloads/#ribs-like-helpers","title":"RIBs like helpers","text":"<p>Adds client code helper classes like <code>Builder</code>, <code>SimpleBuilder</code>, and <code>Interactor</code></p> <pre><code>dependencies {\n    implementation(\"com.bumble.appyx:utils-ribs-helpers:$version\")\n}\n</code></pre>"},{"location":"releases/downloads/#testing","title":"Testing","text":"<pre><code>// Test rules and utility classes for testing on Android\ndebugImplementation(\"com.bumble.appyx:utils-testing-ui-activity:$version\")\nandroidTestImplementation(\"com.bumble.appyx:utils-testing-ui:$version\")\n\n// Utility classes for unit testing\ntestImplementation(\"com.bumble.appyx:utils-testing-unit-common:$version\")\n\n// Test rules and utility classes for unit testing using JUnit4\ntestImplementation(\"com.bumble.appyx:utils-testing-junit4:$version\")\n\n// Test extensions and utility classes for unit testing using JUnit5\ntestImplementation(\"com.bumble.appyx:utils-testing-junit5:$version\")\n</code></pre>"}]}